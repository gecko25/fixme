{"version":3,"sources":["amdefine.js"],"names":[],"mappings":"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","file":"amdefine-compiled.js","sourcesContent":["/** vim: et:ts=4:sw=4:sts=4\n * @license amdefine 1.0.0 Copyright (c) 2011-2015, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/amdefine for details\n */\n\n/*jslint node: true */\n/*global module, process */\n'use strict';\n\n/**\n * Creates a define for node.\n * @param {Object} module the \"module\" object that is defined by Node for the\n * current module.\n * @param {Function} [requireFn]. Node's require function for the current module.\n * It only needs to be passed in Node versions before 0.5, when module.require\n * did not exist.\n * @returns {Function} a define function that is usable for the current node\n * module.\n */\nfunction amdefine(module, requireFn) {\n    'use strict';\n    var defineCache = {},\n        loaderCache = {},\n        alreadyCalled = false,\n        path = require('path'),\n        makeRequire, stringRequire;\n\n    /**\n     * Trims the . and .. from an array of path segments.\n     * It will keep a leading path segment if a .. will become\n     * the first path segment, to help with module name lookups,\n     * which act like paths, but can be remapped. But the end result,\n     * all paths that use this function should look normalized.\n     * NOTE: this method MODIFIES the input array.\n     * @param {Array} ary the array of path segments.\n     */\n    function trimDots(ary) {\n        var i, part;\n        for (i = 0; ary[i]; i+= 1) {\n            part = ary[i];\n            if (part === '.') {\n                ary.splice(i, 1);\n                i -= 1;\n            } else if (part === '..') {\n                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {\n                    //End of the line. Keep at least one non-dot\n                    //path segment at the front so it can be mapped\n                    //correctly to disk. Otherwise, there is likely\n                    //no path mapping for a path starting with '..'.\n                    //This can still fail, but catches the most reasonable\n                    //uses of ..\n                    break;\n                } else if (i > 0) {\n                    ary.splice(i - 1, 2);\n                    i -= 2;\n                }\n            }\n        }\n    }\n\n    function normalize(name, baseName) {\n        var baseParts;\n\n        //Adjust any relative paths.\n        if (name && name.charAt(0) === '.') {\n            //If have a base name, try to normalize against it,\n            //otherwise, assume it is a top-level require that will\n            //be relative to baseUrl in the end.\n            if (baseName) {\n                baseParts = baseName.split('/');\n                baseParts = baseParts.slice(0, baseParts.length - 1);\n                baseParts = baseParts.concat(name.split('/'));\n                trimDots(baseParts);\n                name = baseParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    /**\n     * Create the normalize() function passed to a loader plugin's\n     * normalize method.\n     */\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(id) {\n        function load(value) {\n            loaderCache[id] = value;\n        }\n\n        load.fromText = function (id, text) {\n            //This one is difficult because the text can/probably uses\n            //define, and any relative paths and requires should be relative\n            //to that id was it would be found on disk. But this would require\n            //bootstrapping a module/require fairly deeply from node core.\n            //Not sure how best to go about that yet.\n            throw new Error('amdefine does not implement load.fromText');\n        };\n\n        return load;\n    }\n\n    makeRequire = function (systemRequire, exports, module, relId) {\n        function amdRequire(deps, callback) {\n            if (typeof deps === 'string') {\n                //Synchronous, single module require('')\n                return stringRequire(systemRequire, exports, module, deps, relId);\n            } else {\n                //Array of dependencies with a callback.\n\n                //Convert the dependencies to modules.\n                deps = deps.map(function (depName) {\n                    return stringRequire(systemRequire, exports, module, depName, relId);\n                });\n\n                //Wait for next tick to call back the require call.\n                if (callback) {\n                    process.nextTick(function () {\n                        callback.apply(null, deps);\n                    });\n                }\n            }\n        }\n\n        amdRequire.toUrl = function (filePath) {\n            if (filePath.indexOf('.') === 0) {\n                return normalize(filePath, path.dirname(module.filename));\n            } else {\n                return filePath;\n            }\n        };\n\n        return amdRequire;\n    };\n\n    //Favor explicit value, passed in if the module wants to support Node 0.4.\n    requireFn = requireFn || function req() {\n        return module.require.apply(module, arguments);\n    };\n\n    function runFactory(id, deps, factory) {\n        var r, e, m, result;\n\n        if (id) {\n            e = loaderCache[id] = {};\n            m = {\n                id: id,\n                uri: __filename,\n                exports: e\n            };\n            r = makeRequire(requireFn, e, m, id);\n        } else {\n            //Only support one define call per file\n            if (alreadyCalled) {\n                throw new Error('amdefine with no module ID cannot be called more than once per file.');\n            }\n            alreadyCalled = true;\n\n            //Use the real variables from node\n            //Use module.exports for exports, since\n            //the exports in here is amdefine exports.\n            e = module.exports;\n            m = module;\n            r = makeRequire(requireFn, e, m, module.id);\n        }\n\n        //If there are dependencies, they are strings, so need\n        //to convert them to dependency values.\n        if (deps) {\n            deps = deps.map(function (depName) {\n                return r(depName);\n            });\n        }\n\n        //Call the factory with the right dependencies.\n        if (typeof factory === 'function') {\n            result = factory.apply(m.exports, deps);\n        } else {\n            result = factory;\n        }\n\n        if (result !== undefined) {\n            m.exports = result;\n            if (id) {\n                loaderCache[id] = m.exports;\n            }\n        }\n    }\n\n    stringRequire = function (systemRequire, exports, module, id, relId) {\n        //Split the ID by a ! so that\n        var index = id.indexOf('!'),\n            originalId = id,\n            prefix, plugin;\n\n        if (index === -1) {\n            id = normalize(id, relId);\n\n            //Straight module lookup. If it is one of the special dependencies,\n            //deal with it, otherwise, delegate to node.\n            if (id === 'require') {\n                return makeRequire(systemRequire, exports, module, relId);\n            } else if (id === 'exports') {\n                return exports;\n            } else if (id === 'module') {\n                return module;\n            } else if (loaderCache.hasOwnProperty(id)) {\n                return loaderCache[id];\n            } else if (defineCache[id]) {\n                runFactory.apply(null, defineCache[id]);\n                return loaderCache[id];\n            } else {\n                if(systemRequire) {\n                    return systemRequire(originalId);\n                } else {\n                    throw new Error('No module with ID: ' + id);\n                }\n            }\n        } else {\n            //There is a plugin in play.\n            prefix = id.substring(0, index);\n            id = id.substring(index + 1, id.length);\n\n            plugin = stringRequire(systemRequire, exports, module, prefix, relId);\n\n            if (plugin.normalize) {\n                id = plugin.normalize(id, makeNormalize(relId));\n            } else {\n                //Normalize the ID normally.\n                id = normalize(id, relId);\n            }\n\n            if (loaderCache[id]) {\n                return loaderCache[id];\n            } else {\n                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});\n\n                return loaderCache[id];\n            }\n        }\n    };\n\n    //Create a define function specific to the module asking for amdefine.\n    function define(id, deps, factory) {\n        if (Array.isArray(id)) {\n            factory = deps;\n            deps = id;\n            id = undefined;\n        } else if (typeof id !== 'string') {\n            factory = id;\n            id = deps = undefined;\n        }\n\n        if (deps && !Array.isArray(deps)) {\n            factory = deps;\n            deps = undefined;\n        }\n\n        if (!deps) {\n            deps = ['require', 'exports', 'module'];\n        }\n\n        //Set up properties for this module. If an ID, then use\n        //internal cache. If no ID, then use the external variables\n        //for this node module.\n        if (id) {\n            //Put the module in deep freeze until there is a\n            //require call for it.\n            defineCache[id] = [id, deps, factory];\n        } else {\n            runFactory(id, deps, factory);\n        }\n    }\n\n    //define.require, which has access to all the values in the\n    //cache. Useful for AMD modules that all have IDs in the file,\n    //but need to finally export a value to node based on one of those\n    //IDs.\n    define.require = function (id) {\n        if (loaderCache[id]) {\n            return loaderCache[id];\n        }\n\n        if (defineCache[id]) {\n            runFactory.apply(null, defineCache[id]);\n            return loaderCache[id];\n        }\n    };\n\n    define.amd = {};\n\n    return define;\n}\n\nmodule.exports = amdefine;\n"]}