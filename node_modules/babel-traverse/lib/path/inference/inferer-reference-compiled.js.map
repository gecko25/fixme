{"version":3,"sources":["inferer-reference.js"],"names":[],"mappings":"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","file":"inferer-reference-compiled.js","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"babel-runtime/helpers/interop-require-wildcard\")[\"default\"];\n\nexports.__esModule = true;\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nexports[\"default\"] = function (node) {\n  if (!this.isReferenced()) return;\n\n  // check if a binding exists of this value and if so then return a union type of all\n  // possible types that the binding could be\n  var binding = this.scope.getBinding(node.name);\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(this, node.name);\n    }\n  }\n\n  // built-in values\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {\n    // todo\n  }\n};\n\nfunction getTypeAnnotationBindingConstantViolations(path, name) {\n  var binding = path.scope.getBinding(name);\n\n  var types = [];\n  path.typeAnnotation = t.unionTypeAnnotation(types);\n\n  var functionConstantViolations = [];\n  var constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n\n  var testType = getConditionalAnnotation(path, name);\n  if (testType) {\n    (function () {\n      var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n\n      // remove constant violations observed before the IfStatement\n      constantViolations = constantViolations.filter(function (path) {\n        return testConstantViolations.indexOf(path) < 0;\n      });\n\n      // clear current types and add in observed test type\n      types.push(testType.typeAnnotation);\n    })();\n  }\n\n  if (constantViolations.length) {\n    // pick one constant from each scope which will represent the last possible\n    // control flow path that it could've taken/been\n    /* This code is broken for the following problems:\n     * It thinks that assignments can only happen in scopes.\n     * What about conditionals, if statements without block,\n     * or guarded assignments.\n     * It also checks to see if one of the assignments is in the\n     * same scope and uses that as the only \"violation\". However,\n     * the binding is returned by `getConstantViolationsBefore` so we for\n     * sure always going to return that as the only \"violation\".\n    let rawConstantViolations = constantViolations.reverse();\n    let visitedScopes = [];\n    constantViolations = [];\n    for (let violation of (rawConstantViolations: Array<NodePath>)) {\n      let violationScope = violation.scope;\n      if (visitedScopes.indexOf(violationScope) >= 0) continue;\n       visitedScopes.push(violationScope);\n      constantViolations.push(violation);\n       if (violationScope === path.scope) {\n        constantViolations = [violation];\n        break;\n      }\n    }*/\n\n    // add back on function constant violations since we can't track calls\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    // push on inferred types of violated paths\n    var _arr = constantViolations;\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var violation = _arr[_i];\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (types.length) {\n    return t.createUnionTypeAnnotation(types);\n  }\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  var violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(function (violation) {\n    violation = violation.resolve();\n    var status = violation._guessExecutionStatusRelativeTo(path);\n    if (functions && status === \"function\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  var operator = path.node.operator;\n\n  var right = path.get(\"right\").resolve();\n  var left = path.get(\"left\").resolve();\n\n  var target = undefined;\n  if (left.isIdentifier({ name: name })) {\n    target = right;\n  } else if (right.isIdentifier({ name: name })) {\n    target = left;\n  }\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    } else if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    } else {\n      return;\n    }\n  } else {\n    if (operator !== \"===\") return;\n  }\n\n  //\n  var typeofPath = undefined;\n  var typePath = undefined;\n  if (left.isUnaryExpression({ operator: \"typeof\" })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({ operator: \"typeof\" })) {\n    typeofPath = right;\n    typePath = left;\n  }\n  if (!typePath && !typeofPath) return;\n\n  // ensure that the type path is a Literal\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n\n  // and that it's a string so we can infer it\n  var typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n\n  // and that the argument of the typeof path references us!\n  if (!typeofPath.get(\"argument\").isIdentifier({ name: name })) return;\n\n  // turn type value into a type annotation\n  return t.createTypeAnnotationBasedOnTypeof(typePath.node.value);\n}\n\nfunction getParentConditionalPath(path) {\n  var parentPath = undefined;\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      } else {\n        return parentPath;\n      }\n    } else {\n      path = parentPath;\n    }\n  }\n}\n\nfunction getConditionalAnnotation(path, name) {\n  var ifStatement = getParentConditionalPath(path);\n  if (!ifStatement) return;\n\n  var test = ifStatement.get(\"test\");\n  var paths = [test];\n  var types = [];\n\n  do {\n    var _path = paths.shift().resolve();\n\n    if (_path.isLogicalExpression()) {\n      paths.push(_path.get(\"left\"));\n      paths.push(_path.get(\"right\"));\n    }\n\n    if (_path.isBinaryExpression()) {\n      var type = inferAnnotationFromBinaryExpression(name, _path);\n      if (type) types.push(type);\n    }\n  } while (paths.length);\n\n  if (types.length) {\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement: ifStatement\n    };\n  } else {\n    return getConditionalAnnotation(ifStatement, name);\n  }\n}\nmodule.exports = exports[\"default\"];"]}