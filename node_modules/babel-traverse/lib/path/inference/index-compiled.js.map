{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index-compiled.js","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"babel-runtime/helpers/interop-require-wildcard\")[\"default\"];\n\nexports.__esModule = true;\nexports.getTypeAnnotation = getTypeAnnotation;\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.couldBeBaseType = couldBeBaseType;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.isGenericType = isGenericType;\n\nvar _inferers = require(\"./inferers\");\n\nvar inferers = _interopRequireWildcard(_inferers);\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\n/**\n * Infer the type of the current `NodePath`.\n */\n\nfunction getTypeAnnotation() {\n  if (this.typeAnnotation) return this.typeAnnotation;\n\n  var type = this._getTypeAnnotation() || t.anyTypeAnnotation();\n  if (t.isTypeAnnotation(type)) type = type.typeAnnotation;\n  return this.typeAnnotation = type;\n}\n\n/**\n * todo: split up this method\n */\n\nfunction _getTypeAnnotation() {\n  var node = this.node;\n\n  if (!node) {\n    // handle initializerless variables, add in checks for loop initializers too\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      var declar = this.parentPath.parentPath;\n      var declarParent = declar.parentPath;\n\n      // for (let NODE in bar) {}\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return t.stringTypeAnnotation();\n      }\n\n      // for (let NODE of bar) {}\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return t.anyTypeAnnotation();\n      }\n\n      return t.voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n\n  var inferer = inferers[node.type];\n  if (inferer) {\n    return inferer.call(this, node);\n  }\n\n  inferer = inferers[this.parentPath.type];\n  if (inferer && inferer.validParent) {\n    return this.parentPath.getTypeAnnotation();\n  }\n}\n\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === \"string\") {\n    return t.isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return t.isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return t.isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return t.isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return t.isMixedTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return t.isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(\"Unknown base type \" + baseName);\n    }\n  }\n}\n\nfunction couldBeBaseType(name) {\n  var type = this.getTypeAnnotation();\n  if (t.isAnyTypeAnnotation(type)) return true;\n\n  if (t.isUnionTypeAnnotation(type)) {\n    var _arr = type.types;\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var type2 = _arr[_i];\n      if (t.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nfunction baseTypeStrictlyMatches(right) {\n  var left = this.getTypeAnnotation();\n  right = right.getTypeAnnotation();\n\n  if (!t.isAnyTypeAnnotation(left) && t.isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n}\n\nfunction isGenericType(genericName) {\n  var type = this.getTypeAnnotation();\n  return t.isGenericTypeAnnotation(type) && t.isIdentifier(type.id, { name: genericName });\n}"]}