{"version":3,"sources":["ancestry.js"],"names":[],"mappings":"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","file":"ancestry-compiled.js","sourcesContent":["// This file contains that retrieve or validate anything related to the current paths ancestry.\n\n\"use strict\";\n\nvar _interopRequireWildcard = require(\"babel-runtime/helpers/interop-require-wildcard\")[\"default\"];\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nexports.__esModule = true;\nexports.findParent = findParent;\nexports.find = find;\nexports.getFunctionParent = getFunctionParent;\nexports.getStatementParent = getStatementParent;\nexports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;\nexports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;\nexports.getAncestry = getAncestry;\nexports.inType = inType;\nexports.inShadow = inShadow;\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\n/**\n * Call the provided `callback` with the `NodePath`s of all the parents.\n * When the `callback` returns a truthy value, we return that node path.\n */\n\nfunction findParent(callback) {\n  var path = this;\n  while (path = path.parentPath) {\n    if (callback(path)) return path;\n  }\n  return null;\n}\n\n/**\n * Description\n */\n\nfunction find(callback) {\n  var path = this;\n  do {\n    if (callback(path)) return path;\n  } while (path = path.parentPath);\n  return null;\n}\n\n/**\n * Get the parent function of the current path.\n */\n\nfunction getFunctionParent() {\n  return this.findParent(function (path) {\n    return path.isFunction() || path.isProgram();\n  });\n}\n\n/**\n * Walk up the tree until we hit a parent node path in a list.\n */\n\nfunction getStatementParent() {\n  var path = this;\n  do {\n    if (Array.isArray(path.container)) {\n      return path;\n    }\n  } while (path = path.parentPath);\n}\n\n/**\n * Get the deepest common ancestor and then from it, get the earliest relationship path\n * to that ancestor.\n *\n * Earliest is defined as being \"before\" all the other nodes in terms of list container\n * position and visiting key.\n */\n\nfunction getEarliestCommonAncestorFrom(paths) {\n  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {\n    var earliest = undefined;\n    var keys = t.VISITOR_KEYS[deepest.type];\n\n    var _arr = ancestries;\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var ancestry = _arr[_i];\n      var path = ancestry[i + 1];\n\n      // first path\n      if (!earliest) {\n        earliest = path;\n        continue;\n      }\n\n      // handle containers\n      if (path.listKey && earliest.listKey === path.listKey) {\n        // we're in the same container so check if we're earlier\n        if (path.key < earliest.key) {\n          earliest = path;\n          continue;\n        }\n      }\n\n      // handle keys\n      var earliestKeyIndex = keys.indexOf(earliest.parentKey);\n      var currentKeyIndex = keys.indexOf(path.parentKey);\n      if (earliestKeyIndex > currentKeyIndex) {\n        // key appears before so it's earlier\n        earliest = path;\n      }\n    }\n\n    return earliest;\n  });\n}\n\n/**\n * Get the earliest path in the tree where the provided `paths` intersect.\n *\n * TODO: Possible optimisation target.\n */\n\nfunction getDeepestCommonAncestorFrom(paths, filter) {\n  // istanbul ignore next\n\n  var _this = this;\n\n  if (!paths.length) {\n    return this;\n  }\n\n  if (paths.length === 1) {\n    return paths[0];\n  }\n\n  // minimum depth of the tree so we know the highest node\n  var minDepth = Infinity;\n\n  // last common ancestor\n  var lastCommonIndex = undefined,\n      lastCommon = undefined;\n\n  // get the ancestors of the path, breaking when the parent exceeds ourselves\n  var ancestries = paths.map(function (path) {\n    var ancestry = [];\n\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== _this);\n\n    // save min depth to avoid going too far in\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n\n    return ancestry;\n  });\n\n  // get the first ancestry so we have a seed to assess all other ancestries with\n  var first = ancestries[0];\n\n  // check ancestor equality\n  depthLoop: for (var i = 0; i < minDepth; i++) {\n    var shouldMatch = first[i];\n\n    var _arr2 = ancestries;\n    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n      var ancestry = _arr2[_i2];\n      if (ancestry[i] !== shouldMatch) {\n        // we've hit a snag\n        break depthLoop;\n      }\n    }\n\n    // next iteration may break so store these so they can be returned\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\n\n/**\n * Build an array of node paths containing the entire ancestry of the current node path.\n *\n * NOTE: The current node path is included in this.\n */\n\nfunction getAncestry() {\n  var path = this;\n  var paths = [];\n  do {\n    paths.push(path);\n  } while (path = path.parentPath);\n  return paths;\n}\n\nfunction inType() {\n  var path = this;\n  while (path) {\n    var _arr3 = arguments;\n\n    for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n      var type = _arr3[_i3];\n      if (path.node.type === type) return true;\n    }\n    path = path.parentPath;\n  }\n\n  return false;\n}\n\n/**\n * Checks whether the binding for 'key' is a local binding in its current function context.\n *\n * Checks if the current path either is, or has a direct parent function that is, inside\n * of a function that is marked for shadowing of a binding matching 'key'. Also returns\n * the parent path if the parent path is an arrow, since arrow functions pass through\n * binding values to their parent, meaning they have no local bindings.\n *\n * Shadowing means that when the given binding is transformed, it will read the binding\n * value from the container containing the shadow function, rather than from inside the\n * shadow function.\n *\n * Function shadowing is acheieved by adding a \"shadow\" property on \"FunctionExpression\"\n * and \"FunctionDeclaration\" node types.\n *\n * Node's \"shadow\" props have the following behavior:\n *\n * - Boolean true will cause the function to shadow both \"this\" and \"arguments\".\n * - {this: false} Shadows \"arguments\" but not \"this\".\n * - {arguments: false} Shadows \"this\" but not \"arguments\".\n *\n * Separately, individual identifiers can be flagged with two flags:\n *\n * - _forceShadow - If truthy, this specific identifier will be bound in the closest\n *    Function that is not flagged \"shadow\", or the Program.\n * - _shadowedFunctionLiteral - When set to a NodePath, this specific identifier will be bound\n *    to this NodePath/Node or the Program. If this path is not found relative to the\n *    starting location path, the closest function will be used.\n *\n * Please Note, these flags are for private internal use only and should be avoided.\n * Only \"shadow\" is a public property that other transforms may manipulate.\n */\n\nfunction inShadow(key) {\n  var parentFn = this.isFunction() ? this : this.findParent(function (p) {\n    return p.isFunction();\n  });\n  if (!parentFn) return;\n\n  if (parentFn.isFunctionExpression() || parentFn.isFunctionDeclaration()) {\n    var shadow = parentFn.node.shadow;\n\n    // this is because sometimes we may have a `shadow` value of:\n    //\n    //   { this: false }\n    //\n    // we need to catch this case if `inShadow` has been passed a `key`\n    if (shadow && (!key || shadow[key] !== false)) {\n      return parentFn;\n    }\n  } else if (parentFn.isArrowFunctionExpression()) {\n    return parentFn;\n  }\n\n  // normal function, we've found our function context\n  return null;\n}"]}