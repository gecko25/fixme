{"version":3,"sources":["introspection.js"],"names":[],"mappings":"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","file":"introspection-compiled.js","sourcesContent":["// This file contains methods responsible for introspecting the current path for certain values.\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nvar _interopRequireWildcard = require(\"babel-runtime/helpers/interop-require-wildcard\")[\"default\"];\n\nexports.__esModule = true;\nexports.matchesPattern = matchesPattern;\nexports.has = has;\nexports.isStatic = isStatic;\nexports.isnt = isnt;\nexports.equals = equals;\nexports.isNodeType = isNodeType;\nexports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;\nexports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;\nexports.isCompletionRecord = isCompletionRecord;\nexports.isStatementOrBlock = isStatementOrBlock;\nexports.referencesImport = referencesImport;\nexports.getSource = getSource;\nexports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;\nexports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;\nexports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;\nexports.resolve = resolve;\nexports._resolve = _resolve;\n\nvar _lodashCollectionIncludes = require(\"lodash/collection/includes\");\n\nvar _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\n/**\n * Match the current node if it matches the provided `pattern`.\n *\n * For example, given the match `React.createClass` it would match the\n * parsed nodes of `React.createClass` and `React[\"createClass\"]`.\n */\n\nfunction matchesPattern(pattern, allowPartial) {\n  // not a member expression\n  if (!this.isMemberExpression()) return false;\n\n  var parts = pattern.split(\".\");\n  var search = [this.node];\n  var i = 0;\n\n  function matches(name) {\n    var part = parts[i];\n    return part === \"*\" || name === part;\n  }\n\n  while (search.length) {\n    var node = search.shift();\n\n    if (allowPartial && i === parts.length) {\n      return true;\n    }\n\n    if (t.isIdentifier(node)) {\n      // this part doesn't match\n      if (!matches(node.name)) return false;\n    } else if (t.isLiteral(node)) {\n      // this part doesn't match\n      if (!matches(node.value)) return false;\n    } else if (t.isMemberExpression(node)) {\n      if (node.computed && !t.isLiteral(node.property)) {\n        // we can't deal with this\n        return false;\n      } else {\n        search.unshift(node.property);\n        search.unshift(node.object);\n        continue;\n      }\n    } else if (t.isThisExpression(node)) {\n      if (!matches(\"this\")) return false;\n    } else {\n      // we can't deal with this\n      return false;\n    }\n\n    // too many parts\n    if (++i > parts.length) {\n      return false;\n    }\n  }\n\n  return i === parts.length;\n}\n\n/**\n * Check whether we have the input `key`. If the `key` references an array then we check\n * if the array has any items, otherwise we just check if it's falsy.\n */\n\nfunction has(key) {\n  var val = this.node && this.node[key];\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\n/**\n * Description\n */\n\nfunction isStatic() {\n  return this.scope.isStatic(this.node);\n}\n\n/**\n * Alias of `has`.\n */\n\nvar is = has;\n\nexports.is = is;\n/**\n * Opposite of `has`.\n */\n\nfunction isnt(key) {\n  return !this.has(key);\n}\n\n/**\n * Check whether the path node `key` strict equals `value`.\n */\n\nfunction equals(key, value) {\n  return this.node[key] === value;\n}\n\n/**\n * Check the type against our stored internal type of the node. This is handy when a node has\n * been removed yet we still internally know the type and need it to calculate node replacement.\n */\n\nfunction isNodeType(type) {\n  return t.isType(this.type, type);\n}\n\n/**\n * This checks whether or not we're in one of the following positions:\n *\n *   for (KEY in right);\n *   for (KEY;;);\n *\n * This is because these spots allow VariableDeclarations AND normal expressions so we need\n * to tell the path replacement that it's ok to replace this with an expression.\n */\n\nfunction canHaveVariableDeclarationOrExpression() {\n  return (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor();\n}\n\n/**\n * This checks whether we are swapping an arrow function's body between an\n * expression and a block statement (or vice versa).\n *\n * This is because arrow functions may implicitly return an expression, which\n * is the same as containing a block statement.\n */\n\nfunction canSwapBetweenExpressionAndStatement(replacement) {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return t.isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return t.isExpression(replacement);\n  }\n\n  return false;\n}\n\n/**\n * Check whether the current path references a completion record\n */\n\nfunction isCompletionRecord(allowInsideFunction) {\n  var path = this;\n  var first = true;\n\n  do {\n    var container = path.container;\n\n    // we're in a function so can't be a completion record\n    if (path.isFunction() && !first) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    // check to see if we're the last item in the container and if we are\n    // we're a completion record!\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while ((path = path.parentPath) && !path.isProgram());\n\n  return true;\n}\n\n/**\n * Check whether or not the current `key` allows either a single statement or block statement\n * so we can explode it if necessary.\n */\n\nfunction isStatementOrBlock() {\n  if (this.parentPath.isLabeledStatement() || t.isBlockStatement(this.container)) {\n    return false;\n  } else {\n    return _lodashCollectionIncludes2[\"default\"](t.STATEMENT_OR_BLOCK_KEYS, this.key);\n  }\n}\n\n/**\n * Check if the currently assigned path references the `importName` of `moduleSource`.\n */\n\nfunction referencesImport(moduleSource, importName) {\n  if (!this.isReferencedIdentifier()) return false;\n\n  var binding = this.scope.getBinding(this.node.name);\n  if (!binding || binding.kind !== \"module\") return false;\n\n  var path = binding.path;\n  var parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  // check moduleSource\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (path.isImportSpecifier() && path.node.imported.name === importName) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Get the source code associated with this node.\n */\n\nfunction getSource() {\n  var node = this.node;\n  if (node.end) {\n    return this.hub.file.code.slice(node.start, node.end);\n  } else {\n    return \"\";\n  }\n}\n\nfunction willIMaybeExecuteBefore(target) {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\n/**\n * Given a `target` check the execution status of it relative to the current path.\n *\n * \"Execution status\" simply refers to where or not we **think** this will execuete\n * before or after the input `target` element.\n */\n\nfunction _guessExecutionStatusRelativeTo(target) {\n  // check if the two paths are in different functions, we can't track execution of these\n  var targetFuncParent = target.scope.getFunctionParent();\n  var selfFuncParent = this.scope.getFunctionParent();\n\n  // here we check the `node` equality as sometimes we may have different paths for the\n  // same node due to path thrashing\n  if (targetFuncParent.node !== selfFuncParent.node) {\n    var _status = this._guessExecutionStatusRelativeToDifferentFunctions(targetFuncParent);\n    if (_status) {\n      return _status;\n    } else {\n      target = targetFuncParent.path;\n    }\n  }\n\n  var targetPaths = target.getAncestry();\n  if (targetPaths.indexOf(this) >= 0) return \"after\";\n\n  var selfPaths = this.getAncestry();\n\n  // get ancestor where the branches intersect\n  var commonPath = undefined;\n  var targetIndex = undefined;\n  var selfIndex = undefined;\n  for (selfIndex = 0; selfIndex < selfPaths.length; selfIndex++) {\n    var selfPath = selfPaths[selfIndex];\n    targetIndex = targetPaths.indexOf(selfPath);\n    if (targetIndex >= 0) {\n      commonPath = selfPath;\n      break;\n    }\n  }\n  if (!commonPath) {\n    return \"before\";\n  }\n\n  // get the relationship paths that associate these nodes to their common ancestor\n  var targetRelationship = targetPaths[targetIndex - 1];\n  var selfRelationship = selfPaths[selfIndex - 1];\n  if (!targetRelationship || !selfRelationship) {\n    return \"before\";\n  }\n\n  // container list so let's see which one is after the other\n  if (targetRelationship.listKey && targetRelationship.container === selfRelationship.container) {\n    return targetRelationship.key > selfRelationship.key ? \"before\" : \"after\";\n  }\n\n  // otherwise we're associated by a parent node, check which key comes before the other\n  var targetKeyPosition = t.VISITOR_KEYS[targetRelationship.type].indexOf(targetRelationship.key);\n  var selfKeyPosition = t.VISITOR_KEYS[selfRelationship.type].indexOf(selfRelationship.key);\n  return targetKeyPosition > selfKeyPosition ? \"before\" : \"after\";\n}\n\nfunction _guessExecutionStatusRelativeToDifferentFunctions(targetFuncParent) {\n  var targetFuncPath = targetFuncParent.path;\n  if (!targetFuncPath.isFunctionDeclaration()) return;\n\n  // so we're in a completely different function, if this is a function declaration\n  // then we can be a bit smarter and handle cases where the function is either\n  // a. not called at all (part of an export)\n  // b. called directly\n  var binding = targetFuncPath.scope.getBinding(targetFuncPath.node.id.name);\n\n  // no references!\n  if (!binding.references) return \"before\";\n\n  var referencePaths = binding.referencePaths;\n\n  // verify that all of the references are calls\n  for (var _i = 0; _i < referencePaths.length; _i++) {\n    var path = referencePaths[_i];\n    if (path.key !== \"callee\" || !path.parentPath.isCallExpression()) {\n      return;\n    }\n  }\n\n  var allStatus = undefined;\n\n  // verify that all the calls have the same execution status\n  for (var _i2 = 0; _i2 < referencePaths.length; _i2++) {\n    var path = referencePaths[_i2];\n    // if a reference is a child of the function we're checking against then we can\n    // safelty ignore it\n    var childOfFunction = !!path.find(function (path) {\n      return path.node === targetFuncPath.node;\n    });\n    if (childOfFunction) continue;\n\n    var _status2 = this._guessExecutionStatusRelativeTo(path);\n\n    if (allStatus) {\n      if (allStatus !== _status2) return;\n    } else {\n      allStatus = _status2;\n    }\n  }\n\n  return allStatus;\n}\n\n/**\n * Resolve a \"pointer\" `NodePath` to it's absolute path.\n */\n\nfunction resolve(dangerous, resolved) {\n  return this._resolve(dangerous, resolved) || this;\n}\n\nfunction _resolve(dangerous, resolved) {\n  // istanbul ignore next\n\n  var _this = this;\n\n  // detect infinite recursion\n  // todo: possibly have a max length on this just to be safe\n  if (resolved && resolved.indexOf(this) >= 0) return;\n\n  // we store all the paths we've \"resolved\" in this array to prevent infinite recursion\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {\n      // otherwise it's a request for a pattern and that's a bit more tricky\n    }\n  } else if (this.isReferencedIdentifier()) {\n      var binding = this.scope.getBinding(this.node.name);\n      if (!binding) return;\n\n      // reassigned so we can't really resolve it\n      if (!binding.constant) return;\n\n      // todo - lookup module in dependency graph\n      if (binding.kind === \"module\") return;\n\n      if (binding.path !== this) {\n        var _ret = (function () {\n          var ret = binding.path.resolve(dangerous, resolved);\n          // If the identifier resolves to parent node then we can't really resolve it.\n          if (_this.find(function (parent) {\n            return parent.node === ret.node;\n          })) return {\n              v: undefined\n            };\n          return {\n            v: ret\n          };\n        })();\n\n        // istanbul ignore next\n        if (typeof _ret === \"object\") return _ret.v;\n      }\n    } else if (this.isTypeCastExpression()) {\n      return this.get(\"expression\").resolve(dangerous, resolved);\n    } else if (dangerous && this.isMemberExpression()) {\n      // this is dangerous, as non-direct target assignments will mutate it's state\n      // making this resolution inaccurate\n\n      var targetKey = this.toComputedKey();\n      if (!t.isLiteral(targetKey)) return;\n\n      var targetName = targetKey.value;\n\n      var target = this.get(\"object\").resolve(dangerous, resolved);\n\n      if (target.isObjectExpression()) {\n        var props = target.get(\"properties\");\n        var _arr = props;\n        for (var _i3 = 0; _i3 < _arr.length; _i3++) {\n          var prop = _arr[_i3];\n          if (!prop.isProperty()) continue;\n\n          var key = prop.get(\"key\");\n\n          // { foo: obj }\n          var match = prop.isnt(\"computed\") && key.isIdentifier({ name: targetName });\n\n          // { \"foo\": \"obj\" } or { [\"foo\"]: \"obj\" }\n          match = match || key.isLiteral({ value: targetName });\n\n          if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n        }\n      } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n        var elems = target.get(\"elements\");\n        var elem = elems[targetName];\n        if (elem) return elem.resolve(dangerous, resolved);\n      }\n    }\n}"]}