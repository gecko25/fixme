{"version":3,"sources":["removal-hooks.js"],"names":[],"mappings":";;;;;;AAMA;;AAEA,QAAQ,UAAR,GAAqB,IAArB;AACA,IAAI,QAAQ,CAAC,UAAU,IAAV,EAAgB,MAAhB,EAAwB;AACnC,MAAI,KAAK,GAAL,KAAa,MAAb,IAAuB,OAAO,yBAAP,EAAvB,EAA2D;AAC7D,SAAK,WAAL,CAAiB,KAAK,KAAL,CAAW,kBAAX,EAAjB,EAD6D;AAE7D,WAAO,IAAP,CAF6D;GAA/D;CADW,EAKV,UAAU,IAAV,EAAgB,MAAhB,EAAwB;AACzB,MAAI,eAAe,KAAf;;;;;AADqB,cAMzB,GAAe,gBAAgB,KAAK,GAAL,KAAa,MAAb,KAAwB,OAAO,OAAP,MAAoB,OAAO,YAAP,EAApB,CAAxB;;;;AANN,cAUzB,GAAe,gBAAgB,KAAK,GAAL,KAAa,aAAb,IAA8B,OAAO,mBAAP,EAA9B;;;;AAVN,cAczB,GAAe,gBAAgB,KAAK,GAAL,KAAa,MAAb,IAAuB,OAAO,kBAAP,EAAvB;;;;AAdN,cAkBzB,GAAe,gBAAgB,KAAK,OAAL,KAAiB,cAAjB,IAAmC,OAAO,qBAAP,EAAnC,IAAqE,OAAO,IAAP,CAAY,YAAZ,CAAyB,MAAzB,KAAoC,CAApC;;;;AAlB3E,cAsBzB,GAAe,gBAAgB,KAAK,GAAL,KAAa,YAAb,IAA6B,OAAO,qBAAP,EAA7B,CAtBN;;AAwBzB,MAAI,YAAJ,EAAkB;AAChB,WAAO,MAAP,GADgB;AAEhB,WAAO,IAAP,CAFgB;GAAlB;CAxBC,EA4BA,UAAU,IAAV,EAAgB,MAAhB,EAAwB;AACzB,MAAI,OAAO,oBAAP,MAAiC,OAAO,IAAP,CAAY,WAAZ,CAAwB,MAAxB,KAAmC,CAAnC,EAAsC;;;;AAIzE,WAAO,WAAP,CAAmB,OAAO,IAAP,CAAY,WAAZ,CAAwB,CAAxB,CAAnB,EAJyE;AAKzE,WAAO,IAAP,CALyE;GAA3E;CADC,EAQA,UAAU,IAAV,EAAgB,MAAhB,EAAwB;AACzB,MAAI,OAAO,QAAP,EAAJ,EAAuB;;;;AAIrB,QAAI,KAAK,GAAL,KAAa,MAAb,EAAqB;AACvB,aAAO,WAAP,CAAmB,OAAO,IAAP,CAAY,KAAZ,CAAnB,CADuB;KAAzB,MAEO;;AAEL,aAAO,WAAP,CAAmB,OAAO,IAAP,CAAY,IAAZ,CAAnB,CAFK;KAFP;AAMA,WAAO,IAAP,CAVqB;GAAvB;CADC,CAzCC;AAuDJ,QAAQ,KAAR,GAAgB,KAAhB","file":"removal-hooks-compiled.js","sourcesContent":["// this file contains hooks that handle ancestry cleanup of parent nodes when removing children\n\n/**\n * Pre hooks should be used for either rejecting removal or delegating removal\n */\n\n\"use strict\";\n\nexports.__esModule = true;\nvar hooks = [function (self, parent) {\n  if (self.key === \"body\" && parent.isArrowFunctionExpression()) {\n    self.replaceWith(self.scope.buildUndefinedNode());\n    return true;\n  }\n}, function (self, parent) {\n  var removeParent = false;\n\n  // while (NODE);\n  // removing the test of a while/switch, we can either just remove it entirely *or* turn the `test` into `true`\n  // unlikely that the latter will ever be what's wanted so we just remove the loop to avoid infinite recursion\n  removeParent = removeParent || self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase());\n\n  // export NODE;\n  // just remove a declaration for an export as this is no longer valid\n  removeParent = removeParent || self.key === \"declaration\" && parent.isExportDeclaration();\n\n  // label: NODE\n  // stray labeled statement with no body\n  removeParent = removeParent || self.key === \"body\" && parent.isLabeledStatement();\n\n  // let NODE;\n  // remove an entire declaration if there are no declarators left\n  removeParent = removeParent || self.listKey === \"declarations\" && parent.isVariableDeclaration() && parent.node.declarations.length === 1;\n\n  // NODE;\n  // remove the entire expression statement if there's no expression\n  removeParent = removeParent || self.key === \"expression\" && parent.isExpressionStatement();\n\n  if (removeParent) {\n    parent.remove();\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n    // (node, NODE);\n    // we've just removed the second element of a sequence expression so let's turn that sequence\n    // expression into a regular expression\n    parent.replaceWith(parent.node.expressions[0]);\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isBinary()) {\n    // left + NODE;\n    // NODE + right;\n    // we're in a binary expression, better remove it and replace it with the last expression\n    if (self.key === \"left\") {\n      parent.replaceWith(parent.node.right);\n    } else {\n      // key === \"right\"\n      parent.replaceWith(parent.node.left);\n    }\n    return true;\n  }\n}];\nexports.hooks = hooks;"]}