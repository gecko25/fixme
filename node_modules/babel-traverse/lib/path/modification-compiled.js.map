{"version":3,"sources":["modification.js"],"names":[],"mappings":"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","file":"modification-compiled.js","sourcesContent":["/* eslint max-len: 0 */\n// This file contains methods that modify the path/node in some ways.\n\n\"use strict\";\n\nvar _getIterator = require(\"babel-runtime/core-js/get-iterator\")[\"default\"];\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nvar _interopRequireWildcard = require(\"babel-runtime/helpers/interop-require-wildcard\")[\"default\"];\n\nexports.__esModule = true;\nexports.insertBefore = insertBefore;\nexports._containerInsert = _containerInsert;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._containerInsertAfter = _containerInsertAfter;\nexports._maybePopFromStatements = _maybePopFromStatements;\nexports.insertAfter = insertAfter;\nexports.updateSiblingKeys = updateSiblingKeys;\nexports._verifyNodeList = _verifyNodeList;\nexports.unshiftContainer = unshiftContainer;\nexports.pushContainer = pushContainer;\nexports.hoist = hoist;\n\nvar _cache = require(\"../cache\");\n\nvar _libHoister = require(\"./lib/hoister\");\n\nvar _libHoister2 = _interopRequireDefault(_libHoister);\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\n/**\n * Insert the provided nodes before the current one.\n */\n\nfunction insertBefore(nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  if (this.parentPath.isExpressionStatement() || this.parentPath.isLabeledStatement()) {\n    return this.parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") || this.parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    this.replaceExpressionWithStatements(nodes);\n  } else {\n    this._maybePopFromStatements(nodes);\n    if (Array.isArray(this.container)) {\n      return this._containerInsertBefore(nodes);\n    } else if (this.isStatementOrBlock()) {\n      if (this.node) nodes.push(this.node);\n      this._replaceWith(t.blockStatement(nodes));\n    } else {\n      throw new Error(\"We don't know what to do with this node type. We were previously a Statement but we can't fit in here?\");\n    }\n  }\n\n  return [this];\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n\n  var paths = [];\n\n  for (var i = 0; i < nodes.length; i++) {\n    var to = from + i;\n    var node = nodes[i];\n    this.container.splice(to, 0, node);\n\n    if (this.context) {\n      var path = this.context.create(this.parent, this.container, to, this.listKey);\n\n      // While this path may have a context, there is currently no guarantee that the context\n      // will be the active context, because `popContext` may leave a final context in place.\n      // We should remove this `if` and always push once T7171 has been resolved.\n      if (this.context.queue) path.pushContext(this.context);\n      paths.push(path);\n    } else {\n      paths.push(_index2[\"default\"].get({\n        parentPath: this.parentPath,\n        parent: this.parent,\n        container: this.container,\n        listKey: this.listKey,\n        key: to\n      }));\n    }\n  }\n\n  var contexts = this._getQueueContexts();\n\n  for (var _iterator = paths, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var path = _ref;\n\n    path.setScope();\n    path.debug(function () {\n      return \"Inserted.\";\n    });\n\n    for (var _iterator2 = contexts, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var context = _ref2;\n\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction _maybePopFromStatements(nodes) {\n  var last = nodes[nodes.length - 1];\n  var isIdentifier = t.isIdentifier(last) || t.isExpressionStatement(last) && t.isIdentifier(last.expression);\n\n  if (isIdentifier && !this.isCompletionRecord()) {\n    nodes.pop();\n  }\n}\n\n/**\n * Insert the provided nodes after the current one. When inserting nodes after an\n * expression, ensure that the completion record is correct by pushing the current node.\n */\n\nfunction insertAfter(nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  if (this.parentPath.isExpressionStatement() || this.parentPath.isLabeledStatement()) {\n    return this.parentPath.insertAfter(nodes);\n  } else if (this.isNodeType(\"Expression\") || this.parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      var temp = this.scope.generateDeclaredUidIdentifier();\n      nodes.unshift(t.expressionStatement(t.assignmentExpression(\"=\", temp, this.node)));\n      nodes.push(t.expressionStatement(temp));\n    }\n    this.replaceExpressionWithStatements(nodes);\n  } else {\n    this._maybePopFromStatements(nodes);\n    if (Array.isArray(this.container)) {\n      return this._containerInsertAfter(nodes);\n    } else if (this.isStatementOrBlock()) {\n      if (this.node) nodes.unshift(this.node);\n      this._replaceWith(t.blockStatement(nodes));\n    } else {\n      throw new Error(\"We don't know what to do with this node type. We were previously a Statement but we can't fit in here?\");\n    }\n  }\n\n  return [this];\n}\n\n/**\n * Update all sibling node paths after `fromIndex` by `incrementBy`.\n */\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  var paths = _cache.path.get(this.parent);\n  for (var i = 0; i < paths.length; i++) {\n    var path = paths[i];\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (nodes.constructor !== Array) {\n    nodes = [nodes];\n  }\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    var msg = undefined;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index2[\"default\"]) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      var type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(\"Node list \" + msg + \" with the index of \" + i + \" and type of \" + type);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  // get the first path and insert our nodes before it, if it doesn't exist then it\n  // doesn't matter, our nodes will be inserted anyway\n  var path = _index2[\"default\"].get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey: listKey,\n    key: 0\n  });\n\n  return path.insertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  // get an invisible path that represents the last node + 1 and replace it with our\n  // nodes, effectively inlining it\n\n  var container = this.node[listKey];\n  var path = _index2[\"default\"].get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey: listKey,\n    key: container.length\n  });\n\n  return path.replaceWithMultiple(nodes);\n}\n\n/**\n * Hoist the current node to the highest scope possible and return a UID\n * referencing it.\n */\n\nfunction hoist() {\n  var scope = arguments.length <= 0 || arguments[0] === undefined ? this.scope : arguments[0];\n\n  var hoister = new _libHoister2[\"default\"](this, scope);\n  return hoister.run();\n}"]}