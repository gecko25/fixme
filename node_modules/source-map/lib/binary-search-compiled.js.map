{"version":3,"sources":["binary-search.js"],"names":[],"mappings":";;;;;;;;AAMA;;;;;;;;;;;;;;;;;QAiBW,kBAAT,SAAS,eAAT,CAAyB,IAAzB,EAA+B,KAA/B,EAAsC,OAAtC,EAA+C,SAA/C,EAA0D,QAA1D,EAAoE,KAApE,EAA2E;;;;;;;;;;AAUzE,UAAI,MAAM,KAAK,KAAL,CAAW,CAAC,QAAQ,IAAR,CAAD,GAAiB,CAAjB,CAAX,GAAiC,IAAjC,CAV+D;AAWzE,UAAI,MAAM,SAAS,OAAT,EAAkB,UAAU,GAAV,CAAlB,EAAkC,IAAlC,CAAN,CAXqE;AAYzE,UAAI,QAAQ,CAAR,EAAW;;AAEb,eAAO,GAAP,CAFa;OAAf,MAIK,IAAI,MAAM,CAAN,EAAS;;AAEhB,YAAI,QAAQ,GAAR,GAAc,CAAd,EAAiB;;AAEnB,iBAAO,gBAAgB,GAAhB,EAAqB,KAArB,EAA4B,OAA5B,EAAqC,SAArC,EAAgD,QAAhD,EAA0D,KAA1D,CAAP,CAFmB;SAArB;;;;AAFgB,YASZ,SAAS,QAAQ,iBAAR,EAA2B;AACtC,iBAAO,QAAQ,UAAU,MAAV,GAAmB,KAA3B,GAAmC,CAAC,CAAD,CADJ;SAAxC,MAEO;AACL,iBAAO,GAAP,CADK;SAFP;OATG,MAeA;;AAEH,YAAI,MAAM,IAAN,GAAa,CAAb,EAAgB;;AAElB,iBAAO,gBAAgB,IAAhB,EAAsB,GAAtB,EAA2B,OAA3B,EAAoC,SAApC,EAA+C,QAA/C,EAAyD,KAAzD,CAAP,CAFkB;SAApB;;;AAFG,YAQC,SAAS,QAAQ,iBAAR,EAA2B;AACtC,iBAAO,GAAP,CADsC;SAAxC,MAEO;AACL,iBAAO,OAAO,CAAP,GAAW,CAAC,CAAD,GAAK,IAAhB,CADF;SAFP;OAvBG;KAhBP;;;;;;;;;;;;;;;;;;;;;;AAhBA,YAAQ,oBAAR,GAA+B,CAA/B;AACA,YAAQ,iBAAR,GAA4B,CAA5B,CAgFA,QAAQ,MAAR,GAAiB,SAAS,MAAT,CAAgB,OAAhB,EAAyB,SAAzB,EAAoC,QAApC,EAA8C,KAA9C,EAAqD;AACpE,UAAI,UAAU,MAAV,KAAqB,CAArB,EAAwB;AAC1B,eAAO,CAAC,CAAD,CADmB;OAA5B;;AAIA,UAAI,QAAQ,gBAAgB,CAAC,CAAD,EAAI,UAAU,MAAV,EAAkB,OAAtC,EAA+C,SAA/C,EACgB,QADhB,EAC0B,SAAS,QAAQ,oBAAR,CAD3C,CALgE;AAOpE,UAAI,QAAQ,CAAR,EAAW;AACb,eAAO,CAAC,CAAD,CADM;OAAf;;;;;AAPoE,aAc7D,QAAQ,CAAR,IAAa,CAAb,EAAgB;AACrB,YAAI,SAAS,UAAU,KAAV,CAAT,EAA2B,UAAU,QAAQ,CAAR,CAArC,EAAiD,IAAjD,MAA2D,CAA3D,EAA8D;AAChE,gBADgE;SAAlE;AAGA,UAAE,KAAF,CAJqB;OAAvB;;AAOA,aAAO,KAAP,CArBoE;KAArD;OAlFnB","file":"binary-search-compiled.js","sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n{\n  exports.GREATEST_LOWER_BOUND = 1;\n  exports.LEAST_UPPER_BOUND = 2;\n\n  /**\n   * Recursive implementation of binary search.\n   *\n   * @param aLow Indices here and lower do not contain the needle.\n   * @param aHigh Indices here and higher do not contain the needle.\n   * @param aNeedle The element being searched for.\n   * @param aHaystack The non-empty array being searched.\n   * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   */\n  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n    // This function terminates when one of the following is true:\n    //\n    //   1. We find the exact element we are looking for.\n    //\n    //   2. We did not find the exact element, but we can return the index of\n    //      the next-closest element.\n    //\n    //   3. We did not find the exact element, and there is no next-closest\n    //      element than the one we are searching for, so we return -1.\n    var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n    var cmp = aCompare(aNeedle, aHaystack[mid], true);\n    if (cmp === 0) {\n      // Found the element we are looking for.\n      return mid;\n    }\n    else if (cmp > 0) {\n      // Our needle is greater than aHaystack[mid].\n      if (aHigh - mid > 1) {\n        // The element is in the upper half.\n        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n      }\n\n      // The exact needle element was not found in this haystack. Determine if\n      // we are in termination case (3) or (2) and return the appropriate thing.\n      if (aBias == exports.LEAST_UPPER_BOUND) {\n        return aHigh < aHaystack.length ? aHigh : -1;\n      } else {\n        return mid;\n      }\n    }\n    else {\n      // Our needle is less than aHaystack[mid].\n      if (mid - aLow > 1) {\n        // The element is in the lower half.\n        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n      }\n\n      // we are in termination case (3) or (2) and return the appropriate thing.\n      if (aBias == exports.LEAST_UPPER_BOUND) {\n        return mid;\n      } else {\n        return aLow < 0 ? -1 : aLow;\n      }\n    }\n  }\n\n  /**\n   * This is an implementation of binary search which will always try and return\n   * the index of the closest element if there is no exact hit. This is because\n   * mappings between original and generated line/col pairs are single points,\n   * and there is an implicit region between each of them, so a miss just means\n   * that you aren't on the very start of a region.\n   *\n   * @param aNeedle The element you are looking for.\n   * @param aHaystack The array that is being searched.\n   * @param aCompare A function which takes the needle and an element in the\n   *     array and returns -1, 0, or 1 depending on whether the needle is less\n   *     than, equal to, or greater than the element, respectively.\n   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n   */\n  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n    if (aHaystack.length === 0) {\n      return -1;\n    }\n\n    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                                aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n    if (index < 0) {\n      return -1;\n    }\n\n    // We have found either the exact element, or the next-closest element than\n    // the one we are searching for. However, there may be more than one such\n    // element. Make sure we always return the smallest of these.\n    while (index - 1 >= 0) {\n      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n        break;\n      }\n      --index;\n    }\n\n    return index;\n  };\n}\n"]}