{"version":3,"sources":["quick-sort.js"],"names":[],"mappings":";;;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;QAqBW,OAAT,SAAS,IAAT,CAAc,GAAd,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB;AACvB,UAAI,OAAO,IAAI,CAAJ,CAAP,CADmB;AAEvB,UAAI,CAAJ,IAAS,IAAI,CAAJ,CAAT,CAFuB;AAGvB,UAAI,CAAJ,IAAS,IAAT,CAHuB;KAAzB;;;;;;;;;;;;QAcS,mBAAT,SAAS,gBAAT,CAA0B,GAA1B,EAA+B,IAA/B,EAAqC;AACnC,aAAO,KAAK,KAAL,CAAW,MAAO,KAAK,MAAL,MAAiB,OAAO,GAAP,CAAjB,CAAzB,CADmC;KAArC;;;;;;;;;;;;;;;;QAgBS,cAAT,SAAS,WAAT,CAAqB,GAArB,EAA0B,UAA1B,EAAsC,CAAtC,EAAyC,CAAzC,EAA4C;;;;;AAK1C,UAAI,IAAI,CAAJ,EAAO;;;;;;;;;;;;AAYT,YAAI,aAAa,iBAAiB,CAAjB,EAAoB,CAApB,CAAb,CAZK;AAaT,YAAI,IAAI,IAAI,CAAJ,CAbC;;AAeT,aAAK,GAAL,EAAU,UAAV,EAAsB,CAAtB,EAfS;AAgBT,YAAI,QAAQ,IAAI,CAAJ,CAAR;;;;;;;;AAhBK,aAwBJ,IAAI,IAAI,CAAJ,EAAO,IAAI,CAAJ,EAAO,GAAvB,EAA4B;AAC1B,cAAI,WAAW,IAAI,CAAJ,CAAX,EAAmB,KAAnB,KAA6B,CAA7B,EAAgC;AAClC,iBAAK,CAAL,CADkC;AAElC,iBAAK,GAAL,EAAU,CAAV,EAAa,CAAb,EAFkC;WAApC;SADF;;AAOA,aAAK,GAAL,EAAU,IAAI,CAAJ,EAAO,CAAjB,EA/BS;AAgCT,YAAI,IAAI,IAAI,CAAJ;;;;AAhCC,mBAoCT,CAAY,GAAZ,EAAiB,UAAjB,EAA6B,CAA7B,EAAgC,IAAI,CAAJ,CAAhC,CApCS;AAqCT,oBAAY,GAAZ,EAAiB,UAAjB,EAA6B,IAAI,CAAJ,EAAO,CAApC,EArCS;OAAX;KALF;;;;;;;;;;;;AAsDA,YAAQ,SAAR,GAAoB,UAAU,GAAV,EAAe,UAAf,EAA2B;AAC7C,kBAAY,GAAZ,EAAiB,UAAjB,EAA6B,CAA7B,EAAgC,IAAI,MAAJ,GAAa,CAAb,CAAhC,CAD6C;KAA3B;OAzGtB","file":"quick-sort-compiled.js","sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n{\n  // It turns out that some (most?) JavaScript engines don't self-host\n  // `Array.prototype.sort`. This makes sense because C++ will likely remain\n  // faster than JS when doing raw CPU-intensive sorting. However, when using a\n  // custom comparator function, calling back and forth between the VM's C++ and\n  // JIT'd JS is rather slow *and* loses JIT type information, resulting in\n  // worse generated code for the comparator function than would be optimal. In\n  // fact, when sorting with a comparator, these costs outweigh the benefits of\n  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n  // a ~3500ms mean speed-up in `bench/bench.html`.\n\n  /**\n   * Swap the elements indexed by `x` and `y` in the array `ary`.\n   *\n   * @param {Array} ary\n   *        The array.\n   * @param {Number} x\n   *        The index of the first item.\n   * @param {Number} y\n   *        The index of the second item.\n   */\n  function swap(ary, x, y) {\n    var temp = ary[x];\n    ary[x] = ary[y];\n    ary[y] = temp;\n  }\n\n  /**\n   * Returns a random integer within the range `low .. high` inclusive.\n   *\n   * @param {Number} low\n   *        The lower bound on the range.\n   * @param {Number} high\n   *        The upper bound on the range.\n   */\n  function randomIntInRange(low, high) {\n    return Math.round(low + (Math.random() * (high - low)));\n  }\n\n  /**\n   * The Quick Sort algorithm.\n   *\n   * @param {Array} ary\n   *        An array to sort.\n   * @param {function} comparator\n   *        Function to use to compare two items.\n   * @param {Number} p\n   *        Start index of the array\n   * @param {Number} r\n   *        End index of the array\n   */\n  function doQuickSort(ary, comparator, p, r) {\n    // If our lower bound is less than our upper bound, we (1) partition the\n    // array into two pieces and (2) recurse on each half. If it is not, this is\n    // the empty array and our base case.\n\n    if (p < r) {\n      // (1) Partitioning.\n      //\n      // The partitioning chooses a pivot between `p` and `r` and moves all\n      // elements that are less than or equal to the pivot to the before it, and\n      // all the elements that are greater than it after it. The effect is that\n      // once partition is done, the pivot is in the exact place it will be when\n      // the array is put in sorted order, and it will not need to be moved\n      // again. This runs in O(n) time.\n\n      // Always choose a random pivot so that an input array which is reverse\n      // sorted does not cause O(n^2) running time.\n      var pivotIndex = randomIntInRange(p, r);\n      var i = p - 1;\n\n      swap(ary, pivotIndex, r);\n      var pivot = ary[r];\n\n      // Immediately after `j` is incremented in this loop, the following hold\n      // true:\n      //\n      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n      //\n      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n      for (var j = p; j < r; j++) {\n        if (comparator(ary[j], pivot) <= 0) {\n          i += 1;\n          swap(ary, i, j);\n        }\n      }\n\n      swap(ary, i + 1, j);\n      var q = i + 1;\n\n      // (2) Recurse on each half.\n\n      doQuickSort(ary, comparator, p, q - 1);\n      doQuickSort(ary, comparator, q + 1, r);\n    }\n  }\n\n  /**\n   * Sort the given array in-place with the given comparator function.\n   *\n   * @param {Array} ary\n   *        An array to sort.\n   * @param {function} comparator\n   *        Function to use to compare two items.\n   */\n  exports.quickSort = function (ary, comparator) {\n    doQuickSort(ary, comparator, 0, ary.length - 1);\n  };\n}\n"]}