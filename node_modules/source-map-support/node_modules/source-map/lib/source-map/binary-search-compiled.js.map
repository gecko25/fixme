{"version":3,"sources":["binary-search.js"],"names":[],"mappings":";;;;;;;;AAMA,IAAI,OAAO,MAAP,KAAkB,UAAlB,EAA8B;AAC9B,MAAI,SAAS,QAAQ,UAAR,EAAoB,MAApB,EAA4B,OAA5B,CAAT,CAD0B;CAAlC;AAGA,OAAO,UAAU,OAAV,EAAmB,OAAnB,EAA4B,MAA5B,EAAoC;;;;;;;;;;;AAWzC,WAAS,eAAT,CAAyB,IAAzB,EAA+B,KAA/B,EAAsC,OAAtC,EAA+C,SAA/C,EAA0D,QAA1D,EAAoE;;;;;;;;;;;AAWlE,QAAI,MAAM,KAAK,KAAL,CAAW,CAAC,QAAQ,IAAR,CAAD,GAAiB,CAAjB,CAAX,GAAiC,IAAjC,CAXwD;AAYlE,QAAI,MAAM,SAAS,OAAT,EAAkB,UAAU,GAAV,CAAlB,EAAkC,IAAlC,CAAN,CAZ8D;AAalE,QAAI,QAAQ,CAAR,EAAW;;AAEb,aAAO,UAAU,GAAV,CAAP,CAFa;KAAf,MAIK,IAAI,MAAM,CAAN,EAAS;;AAEhB,UAAI,QAAQ,GAAR,GAAc,CAAd,EAAiB;;AAEnB,eAAO,gBAAgB,GAAhB,EAAqB,KAArB,EAA4B,OAA5B,EAAqC,SAArC,EAAgD,QAAhD,CAAP,CAFmB;OAArB;;;AAFgB,aAQT,UAAU,GAAV,CAAP,CARgB;KAAb,MAUA;;AAEH,UAAI,MAAM,IAAN,GAAa,CAAb,EAAgB;;AAElB,eAAO,gBAAgB,IAAhB,EAAsB,GAAtB,EAA2B,OAA3B,EAAoC,SAApC,EAA+C,QAA/C,CAAP,CAFkB;OAApB;;;AAFG,aAQI,OAAO,CAAP,GACH,IADG,GAEH,UAAU,IAAV,CAFG,CARJ;KAVA;GAjBP;;;;;;;;;;;;;;;AAXyC,SAiEzC,CAAQ,MAAR,GAAiB,SAAS,MAAT,CAAgB,OAAhB,EAAyB,SAAzB,EAAoC,QAApC,EAA8C;AAC7D,WAAO,UAAU,MAAV,GAAmB,CAAnB,GACH,gBAAgB,CAAC,CAAD,EAAI,UAAU,MAAV,EAAkB,OAAtC,EAA+C,SAA/C,EAA0D,QAA1D,CADG,GAEH,IAFG,CADsD;GAA9C,CAjEwB;CAApC,CAAP","file":"binary-search-compiled.js","sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (typeof define !== 'function') {\n    var define = require('amdefine')(module, require);\n}\ndefine(function (require, exports, module) {\n\n  /**\n   * Recursive implementation of binary search.\n   *\n   * @param aLow Indices here and lower do not contain the needle.\n   * @param aHigh Indices here and higher do not contain the needle.\n   * @param aNeedle The element being searched for.\n   * @param aHaystack The non-empty array being searched.\n   * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n   */\n  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {\n    // This function terminates when one of the following is true:\n    //\n    //   1. We find the exact element we are looking for.\n    //\n    //   2. We did not find the exact element, but we can return the next\n    //      closest element that is less than that element.\n    //\n    //   3. We did not find the exact element, and there is no next-closest\n    //      element which is less than the one we are searching for, so we\n    //      return null.\n    var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n    var cmp = aCompare(aNeedle, aHaystack[mid], true);\n    if (cmp === 0) {\n      // Found the element we are looking for.\n      return aHaystack[mid];\n    }\n    else if (cmp > 0) {\n      // aHaystack[mid] is greater than our needle.\n      if (aHigh - mid > 1) {\n        // The element is in the upper half.\n        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);\n      }\n      // We did not find an exact match, return the next closest one\n      // (termination case 2).\n      return aHaystack[mid];\n    }\n    else {\n      // aHaystack[mid] is less than our needle.\n      if (mid - aLow > 1) {\n        // The element is in the lower half.\n        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);\n      }\n      // The exact needle element was not found in this haystack. Determine if\n      // we are in termination case (2) or (3) and return the appropriate thing.\n      return aLow < 0\n        ? null\n        : aHaystack[aLow];\n    }\n  }\n\n  /**\n   * This is an implementation of binary search which will always try and return\n   * the next lowest value checked if there is no exact hit. This is because\n   * mappings between original and generated line/col pairs are single points,\n   * and there is an implicit region between each of them, so a miss just means\n   * that you aren't on the very start of a region.\n   *\n   * @param aNeedle The element you are looking for.\n   * @param aHaystack The array that is being searched.\n   * @param aCompare A function which takes the needle and an element in the\n   *     array and returns -1, 0, or 1 depending on whether the needle is less\n   *     than, equal to, or greater than the element, respectively.\n   */\n  exports.search = function search(aNeedle, aHaystack, aCompare) {\n    return aHaystack.length > 0\n      ? recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)\n      : null;\n  };\n\n});\n"]}