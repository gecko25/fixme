{"version":3,"sources":["json5.js"],"names":[],"mappings":"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","file":"json5-compiled.js","sourcesContent":["// json5.js\n// Modern JSON. See README.md for details.\n//\n// This file is based directly off of Douglas Crockford's json_parse.js:\n// https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js\n\nvar JSON5 = (typeof exports === 'object' ? exports : {});\n\nJSON5.parse = (function () {\n    \"use strict\";\n\n// This is a function that can parse a JSON5 text, producing a JavaScript\n// data structure. It is a simple, recursive descent parser. It does not use\n// eval or regular expressions, so it can be used as a model for implementing\n// a JSON5 parser in other languages.\n\n// We are defining the function inside of another function to avoid creating\n// global variables.\n\n    var at,     // The index of the current character\n        ch,     // The current character\n        escapee = {\n            \"'\":  \"'\",\n            '\"':  '\"',\n            '\\\\': '\\\\',\n            '/':  '/',\n            '\\n': '',       // Replace escaped newlines in strings w/ empty string\n            b:    '\\b',\n            f:    '\\f',\n            n:    '\\n',\n            r:    '\\r',\n            t:    '\\t'\n        },\n        ws = [\n            ' ',\n            '\\t',\n            '\\r',\n            '\\n',\n            '\\v',\n            '\\f',\n            '\\xA0',\n            '\\uFEFF'\n        ],\n        text,\n\n        error = function (m) {\n\n// Call error when something is wrong.\n\n            var error = new SyntaxError();\n            error.message = m;\n            error.at = at;\n            error.text = text;\n            throw error;\n        },\n\n        next = function (c) {\n\n// If a c parameter is provided, verify that it matches the current character.\n\n            if (c && c !== ch) {\n                error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n            }\n\n// Get the next character. When there are no more characters,\n// return the empty string.\n\n            ch = text.charAt(at);\n            at += 1;\n            return ch;\n        },\n\n        peek = function () {\n\n// Get the next character without consuming it or\n// assigning it to the ch varaible.\n\n            return text.charAt(at);\n        },\n\n        identifier = function () {\n\n// Parse an identifier. Normally, reserved words are disallowed here, but we\n// only use this for unquoted object keys, where reserved words are allowed,\n// so we don't check for those here. References:\n// - http://es5.github.com/#x7.6\n// - https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Variables\n// - http://docstore.mik.ua/orelly/webprog/jscript/ch02_07.htm\n// TODO Identifiers can have Unicode \"letters\" in them; add support for those.\n\n            var key = ch;\n\n            // Identifiers must start with a letter, _ or $.\n            if ((ch !== '_' && ch !== '$') &&\n                    (ch < 'a' || ch > 'z') &&\n                    (ch < 'A' || ch > 'Z')) {\n                error(\"Bad identifier\");\n            }\n\n            // Subsequent characters can contain digits.\n            while (next() && (\n                    ch === '_' || ch === '$' ||\n                    (ch >= 'a' && ch <= 'z') ||\n                    (ch >= 'A' && ch <= 'Z') ||\n                    (ch >= '0' && ch <= '9'))) {\n                key += ch;\n            }\n\n            return key;\n        },\n\n        number = function () {\n\n// Parse a number value.\n\n            var number,\n                sign = '',\n                string = '',\n                base = 10;\n\n            if (ch === '-' || ch === '+') {\n                sign = ch;\n                next(ch);\n            }\n\n            // support for Infinity (could tweak to allow other words):\n            if (ch === 'I') {\n                number = word();\n                if (typeof number !== 'number' || isNaN(number)) {\n                    error('Unexpected word for number');\n                }\n                return (sign === '-') ? -number : number;\n            }\n\n            // support for NaN\n            if (ch === 'N' ) {\n              number = word();\n              if (!isNaN(number)) {\n                error('expected word to be NaN');\n              }\n              // ignore sign as -NaN also is NaN\n              return number;\n            }\n\n            if (ch === '0') {\n                string += ch;\n                next();\n                if (ch === 'x' || ch === 'X') {\n                    string += ch;\n                    next();\n                    base = 16;\n                } else if (ch >= '0' && ch <= '9') {\n                    error('Octal literal');\n                }\n            }\n\n            switch (base) {\n            case 10:\n                while (ch >= '0' && ch <= '9' ) {\n                    string += ch;\n                    next();\n                }\n                if (ch === '.') {\n                    string += '.';\n                    while (next() && ch >= '0' && ch <= '9') {\n                        string += ch;\n                    }\n                }\n                if (ch === 'e' || ch === 'E') {\n                    string += ch;\n                    next();\n                    if (ch === '-' || ch === '+') {\n                        string += ch;\n                        next();\n                    }\n                    while (ch >= '0' && ch <= '9') {\n                        string += ch;\n                        next();\n                    }\n                }\n                break;\n            case 16:\n                while (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') {\n                    string += ch;\n                    next();\n                }\n                break;\n            }\n\n            if(sign === '-') {\n                number = -string;\n            } else {\n                number = +string;\n            }\n            \n            if (!isFinite(number)) {\n                error(\"Bad number\");\n            } else {\n                return number;\n            }\n        },\n\n        string = function () {\n\n// Parse a string value.\n\n            var hex,\n                i,\n                string = '',\n                delim,      // double quote or single quote\n                uffff;\n\n// When parsing for string values, we must look for ' or \" and \\ characters.\n\n            if (ch === '\"' || ch === \"'\") {\n                delim = ch;\n                while (next()) {\n                    if (ch === delim) {\n                        next();\n                        return string;\n                    } else if (ch === '\\\\') {\n                        next();\n                        if (ch === 'u') {\n                            uffff = 0;\n                            for (i = 0; i < 4; i += 1) {\n                                hex = parseInt(next(), 16);\n                                if (!isFinite(hex)) {\n                                    break;\n                                }\n                                uffff = uffff * 16 + hex;\n                            }\n                            string += String.fromCharCode(uffff);\n                        } else if (ch === '\\r') {\n                            if (peek() === '\\n') {\n                                next();\n                            }\n                        } else if (typeof escapee[ch] === 'string') {\n                            string += escapee[ch];\n                        } else {\n                            break;\n                        }\n                    } else if (ch === '\\n') {\n                        // unescaped newlines are invalid; see:\n                        // https://github.com/aseemk/json5/issues/24\n                        // TODO this feels special-cased; are there other\n                        // invalid unescaped chars?\n                        break;\n                    } else {\n                        string += ch;\n                    }\n                }\n            }\n            error(\"Bad string\");\n        },\n\n        inlineComment = function () {\n\n// Skip an inline comment, assuming this is one. The current character should\n// be the second / character in the // pair that begins this inline comment.\n// To finish the inline comment, we look for a newline or the end of the text.\n\n            if (ch !== '/') {\n                error(\"Not an inline comment\");\n            }\n\n            do {\n                next();\n                if (ch === '\\n' || ch === '\\r') {\n                    next();\n                    return;\n                }\n            } while (ch);\n        },\n\n        blockComment = function () {\n\n// Skip a block comment, assuming this is one. The current character should be\n// the * character in the /* pair that begins this block comment.\n// To finish the block comment, we look for an ending */ pair of characters,\n// but we also watch for the end of text before the comment is terminated.\n\n            if (ch !== '*') {\n                error(\"Not a block comment\");\n            }\n\n            do {\n                next();\n                while (ch === '*') {\n                    next('*');\n                    if (ch === '/') {\n                        next('/');\n                        return;\n                    }\n                }\n            } while (ch);\n\n            error(\"Unterminated block comment\");\n        },\n\n        comment = function () {\n\n// Skip a comment, whether inline or block-level, assuming this is one.\n// Comments always begin with a / character.\n\n            if (ch !== '/') {\n                error(\"Not a comment\");\n            }\n\n            next('/');\n\n            if (ch === '/') {\n                inlineComment();\n            } else if (ch === '*') {\n                blockComment();\n            } else {\n                error(\"Unrecognized comment\");\n            }\n        },\n\n        white = function () {\n\n// Skip whitespace and comments.\n// Note that we're detecting comments by only a single / character.\n// This works since regular expressions are not valid JSON(5), but this will\n// break if there are other valid values that begin with a / character!\n\n            while (ch) {\n                if (ch === '/') {\n                    comment();\n                } else if (ws.indexOf(ch) >= 0) {\n                    next();\n                } else {\n                    return;\n                }\n            }\n        },\n\n        word = function () {\n\n// true, false, or null.\n\n            switch (ch) {\n            case 't':\n                next('t');\n                next('r');\n                next('u');\n                next('e');\n                return true;\n            case 'f':\n                next('f');\n                next('a');\n                next('l');\n                next('s');\n                next('e');\n                return false;\n            case 'n':\n                next('n');\n                next('u');\n                next('l');\n                next('l');\n                return null;\n            case 'I':\n                next('I');\n                next('n');\n                next('f');\n                next('i');\n                next('n');\n                next('i');\n                next('t');\n                next('y');\n                return Infinity;\n            case 'N':\n              next( 'N' );\n              next( 'a' );\n              next( 'N' );\n              return NaN;\n            }\n            error(\"Unexpected '\" + ch + \"'\");\n        },\n\n        value,  // Place holder for the value function.\n\n        array = function () {\n\n// Parse an array value.\n\n            var array = [];\n\n            if (ch === '[') {\n                next('[');\n                white();\n                while (ch) {\n                    if (ch === ']') {\n                        next(']');\n                        return array;   // Potentially empty array\n                    }\n                    // ES5 allows omitting elements in arrays, e.g. [,] and\n                    // [,null]. We don't allow this in JSON5.\n                    if (ch === ',') {\n                        error(\"Missing array element\");\n                    } else {\n                        array.push(value());\n                    }\n                    white();\n                    // If there's no comma after this value, this needs to\n                    // be the end of the array.\n                    if (ch !== ',') {\n                        next(']');\n                        return array;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error(\"Bad array\");\n        },\n\n        object = function () {\n\n// Parse an object value.\n\n            var key,\n                object = {};\n\n            if (ch === '{') {\n                next('{');\n                white();\n                while (ch) {\n                    if (ch === '}') {\n                        next('}');\n                        return object;   // Potentially empty object\n                    }\n\n                    // Keys can be unquoted. If they are, they need to be\n                    // valid JS identifiers.\n                    if (ch === '\"' || ch === \"'\") {\n                        key = string();\n                    } else {\n                        key = identifier();\n                    }\n\n                    white();\n                    next(':');\n                    object[key] = value();\n                    white();\n                    // If there's no comma after this pair, this needs to be\n                    // the end of the object.\n                    if (ch !== ',') {\n                        next('}');\n                        return object;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error(\"Bad object\");\n        };\n\n    value = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n        white();\n        switch (ch) {\n        case '{':\n            return object();\n        case '[':\n            return array();\n        case '\"':\n        case \"'\":\n            return string();\n        case '-':\n        case '+':\n        case '.':\n            return number();\n        default:\n            return ch >= '0' && ch <= '9' ? number() : word();\n        }\n    };\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\n    return function (source, reviver) {\n        var result;\n\n        text = String(source);\n        at = 0;\n        ch = ' ';\n        result = value();\n        white();\n        if (ch) {\n            error(\"Syntax error\");\n        }\n\n// If there is a reviver function, we recursively walk the new structure,\n// passing each name/value pair to the reviver function for possible\n// transformation, starting with a temporary root object that holds the result\n// in an empty key. If there is not a reviver function, we simply return the\n// result.\n\n        return typeof reviver === 'function' ? (function walk(holder, key) {\n            var k, v, value = holder[key];\n            if (value && typeof value === 'object') {\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = walk(value, k);\n                        if (v !== undefined) {\n                            value[k] = v;\n                        } else {\n                            delete value[k];\n                        }\n                    }\n                }\n            }\n            return reviver.call(holder, key, value);\n        }({'': result}, '')) : result;\n    };\n}());\n\n// JSON5 stringify will not quote keys where appropriate\nJSON5.stringify = function (obj, replacer, space) {\n    if (replacer && (typeof(replacer) !== \"function\" && !isArray(replacer))) {\n        throw new Error('Replacer must be a function or an array');\n    }\n    var getReplacedValueOrUndefined = function(holder, key, isTopLevel) {\n        var value = holder[key];\n\n        // Replace the value with its toJSON value first, if possible\n        if (value && value.toJSON && typeof value.toJSON === \"function\") {\n            value = value.toJSON();\n        }\n\n        // If the user-supplied replacer if a function, call it. If it's an array, check objects' string keys for\n        // presence in the array (removing the key/value pair from the resulting JSON if the key is missing).\n        if (typeof(replacer) === \"function\") {\n            return replacer.call(holder, key, value);\n        } else if(replacer) {\n            if (isTopLevel || isArray(holder) || replacer.indexOf(key) >= 0) {\n                return value;\n            } else {\n                return undefined;\n            }\n        } else {\n            return value;\n        }\n    };\n\n    function isWordChar(char) {\n        return (char >= 'a' && char <= 'z') ||\n            (char >= 'A' && char <= 'Z') ||\n            (char >= '0' && char <= '9') ||\n            char === '_' || char === '$';\n    }\n\n    function isWordStart(char) {\n        return (char >= 'a' && char <= 'z') ||\n            (char >= 'A' && char <= 'Z') ||\n            char === '_' || char === '$';\n    }\n\n    function isWord(key) {\n        if (typeof key !== 'string') {\n            return false;\n        }\n        if (!isWordStart(key[0])) {\n            return false;\n        }\n        var i = 1, length = key.length;\n        while (i < length) {\n            if (!isWordChar(key[i])) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    }\n\n    // export for use in tests\n    JSON5.isWord = isWord;\n\n    // polyfills\n    function isArray(obj) {\n        if (Array.isArray) {\n            return Array.isArray(obj);\n        } else {\n            return Object.prototype.toString.call(obj) === '[object Array]';\n        }\n    }\n\n    function isDate(obj) {\n        return Object.prototype.toString.call(obj) === '[object Date]';\n    }\n\n    isNaN = isNaN || function(val) {\n        return typeof val === 'number' && val !== val;\n    };\n\n    var objStack = [];\n    function checkForCircular(obj) {\n        for (var i = 0; i < objStack.length; i++) {\n            if (objStack[i] === obj) {\n                throw new TypeError(\"Converting circular structure to JSON\");\n            }\n        }\n    }\n\n    function makeIndent(str, num, noNewLine) {\n        if (!str) {\n            return \"\";\n        }\n        // indentation no more than 10 chars\n        if (str.length > 10) {\n            str = str.substring(0, 10);\n        }\n\n        var indent = noNewLine ? \"\" : \"\\n\";\n        for (var i = 0; i < num; i++) {\n            indent += str;\n        }\n\n        return indent;\n    }\n\n    var indentStr;\n    if (space) {\n        if (typeof space === \"string\") {\n            indentStr = space;\n        } else if (typeof space === \"number\" && space >= 0) {\n            indentStr = makeIndent(\" \", space, true);\n        } else {\n            // ignore space parameter\n        }\n    }\n\n    // Copied from Crokford's implementation of JSON\n    // See https://github.com/douglascrockford/JSON-js/blob/e39db4b7e6249f04a195e7dd0840e610cc9e941e/json2.js#L195\n    // Begin\n    var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n        escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n        meta = { // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    };\n    function escapeString(string) {\n\n// If the string contains no control characters, no quote characters, and no\n// backslash characters, then we can safely slap some quotes around it.\n// Otherwise we must also replace the offending characters with safe escape\n// sequences.\n        escapable.lastIndex = 0;\n        return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n            var c = meta[a];\n            return typeof c === 'string' ?\n                c :\n                '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n        }) + '\"' : '\"' + string + '\"';\n    }\n    // End\n\n    function internalStringify(holder, key, isTopLevel) {\n        var buffer, res;\n\n        // Replace the value, if necessary\n        var obj_part = getReplacedValueOrUndefined(holder, key, isTopLevel);\n\n        if (obj_part && !isDate(obj_part)) {\n            // unbox objects\n            // don't unbox dates, since will turn it into number\n            obj_part = obj_part.valueOf();\n        }\n        switch(typeof obj_part) {\n            case \"boolean\":\n                return obj_part.toString();\n\n            case \"number\":\n                if (isNaN(obj_part) || !isFinite(obj_part)) {\n                    return \"null\";\n                }\n                return obj_part.toString();\n\n            case \"string\":\n                return escapeString(obj_part.toString());\n\n            case \"object\":\n                if (obj_part === null) {\n                    return \"null\";\n                } else if (isArray(obj_part)) {\n                    checkForCircular(obj_part);\n                    buffer = \"[\";\n                    objStack.push(obj_part);\n\n                    for (var i = 0; i < obj_part.length; i++) {\n                        res = internalStringify(obj_part, i, false);\n                        buffer += makeIndent(indentStr, objStack.length);\n                        if (res === null || typeof res === \"undefined\") {\n                            buffer += \"null\";\n                        } else {\n                            buffer += res;\n                        }\n                        if (i < obj_part.length-1) {\n                            buffer += \",\";\n                        } else if (indentStr) {\n                            buffer += \"\\n\";\n                        }\n                    }\n                    objStack.pop();\n                    buffer += makeIndent(indentStr, objStack.length, true) + \"]\";\n                } else {\n                    checkForCircular(obj_part);\n                    buffer = \"{\";\n                    var nonEmpty = false;\n                    objStack.push(obj_part);\n                    for (var prop in obj_part) {\n                        if (obj_part.hasOwnProperty(prop)) {\n                            var value = internalStringify(obj_part, prop, false);\n                            isTopLevel = false;\n                            if (typeof value !== \"undefined\" && value !== null) {\n                                buffer += makeIndent(indentStr, objStack.length);\n                                nonEmpty = true;\n                                var key = isWord(prop) ? prop : escapeString(prop);\n                                buffer += key + \":\" + (indentStr ? ' ' : '') + value + \",\";\n                            }\n                        }\n                    }\n                    objStack.pop();\n                    if (nonEmpty) {\n                        buffer = buffer.substring(0, buffer.length-1) + makeIndent(indentStr, objStack.length) + \"}\";\n                    } else {\n                        buffer = '{}';\n                    }\n                }\n                return buffer;\n            default:\n                // functions and undefined should be ignored\n                return undefined;\n        }\n    }\n\n    // special case...when undefined is used inside of\n    // a compound object/array, return null.\n    // but when top-level, return undefined\n    var topLevelHolder = {\"\":obj};\n    if (obj === undefined) {\n        return getReplacedValueOrUndefined(topLevelHolder, '', true);\n    }\n    return internalStringify(topLevelHolder, '', true);\n};\n"]}