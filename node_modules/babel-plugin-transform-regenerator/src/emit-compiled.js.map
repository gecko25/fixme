{"version":3,"sources":["emit.js"],"names":[],"mappings":"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","file":"emit-compiled.js","sourcesContent":["/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\nimport assert from \"assert\";\nimport * as t from \"babel-types\";\nimport * as leap from \"./leap\";\nimport * as meta from \"./meta\";\nimport * as util from \"./util\";\n\nlet hasOwn = Object.prototype.hasOwnProperty;\n\nfunction Emitter(contextId) {\n  assert.ok(this instanceof Emitter);\n  t.assertIdentifier(contextId);\n\n  // Used to generate unique temporary names.\n  this.nextTempId = 0;\n\n  // In order to make sure the context object does not collide with\n  // anything in the local scope, we might have to rename it, so we\n  // refer to it symbolically instead of just assuming that it will be\n  // called \"context\".\n  this.contextId = contextId;\n\n  // An append-only list of Statements that grows each time this.emit is\n  // called.\n  this.listing = [];\n\n  // A sparse array whose keys correspond to locations in this.listing\n  // that have been marked as branch/jump targets.\n  this.marked = [true];\n\n  // The last location will be marked when this.getDispatchLoop is\n  // called.\n  this.finalLoc = loc();\n\n  // A list of all leap.TryEntry statements emitted.\n  this.tryEntries = [];\n\n  // Each time we evaluate the body of a loop, we tell this.leapManager\n  // to enter a nested loop context that determines the meaning of break\n  // and continue statements therein.\n  this.leapManager = new leap.LeapManager(this);\n}\n\nlet Ep = Emitter.prototype;\nexports.Emitter = Emitter;\n\n// Offsets into this.listing that could be used as targets for branches or\n// jumps are represented as numeric Literal nodes. This representation has\n// the amazingly convenient benefit of allowing the exact value of the\n// location to be determined at any time, even after generating code that\n// refers to the location.\nfunction loc() {\n  return t.numericLiteral(-1);\n}\n\n// Sets the exact value of the given location to the offset of the next\n// Statement emitted.\nEp.mark = function(loc) {\n  t.assertLiteral(loc);\n  let index = this.listing.length;\n  if (loc.value === -1) {\n    loc.value = index;\n  } else {\n    // Locations can be marked redundantly, but their values cannot change\n    // once set the first time.\n    assert.strictEqual(loc.value, index);\n  }\n  this.marked[index] = true;\n  return loc;\n};\n\nEp.emit = function(node) {\n  if (t.isExpression(node)) {\n    node = t.expressionStatement(node);\n  }\n\n  t.assertStatement(node);\n  this.listing.push(node);\n};\n\n// Shorthand for emitting assignment statements. This will come in handy\n// for assignments to temporary variables.\nEp.emitAssign = function(lhs, rhs) {\n  this.emit(this.assign(lhs, rhs));\n  return lhs;\n};\n\n// Shorthand for an assignment statement.\nEp.assign = function(lhs, rhs) {\n  return t.expressionStatement(\n    t.assignmentExpression(\"=\", lhs, rhs));\n};\n\n// Convenience function for generating expressions like context.next,\n// context.sent, and context.rval.\nEp.contextProperty = function(name, computed) {\n  return t.memberExpression(\n    this.contextId,\n    computed ? t.stringLiteral(name) : t.identifier(name),\n    !!computed\n  );\n};\n\n// Shorthand for setting context.rval and jumping to `context.stop()`.\nEp.stop = function(rval) {\n  if (rval) {\n    this.setReturnValue(rval);\n  }\n\n  this.jump(this.finalLoc);\n};\n\nEp.setReturnValue = function(valuePath) {\n  t.assertExpression(valuePath.value);\n\n  this.emitAssign(\n    this.contextProperty(\"rval\"),\n    this.explodeExpression(valuePath)\n  );\n};\n\nEp.clearPendingException = function(tryLoc, assignee) {\n  t.assertLiteral(tryLoc);\n\n  let catchCall = t.callExpression(\n    this.contextProperty(\"catch\", true),\n    [tryLoc]\n  );\n\n  if (assignee) {\n    this.emitAssign(assignee, catchCall);\n  } else {\n    this.emit(catchCall);\n  }\n};\n\n// Emits code for an unconditional jump to the given location, even if the\n// exact value of the location is not yet known.\nEp.jump = function(toLoc) {\n  this.emitAssign(this.contextProperty(\"next\"), toLoc);\n  this.emit(t.breakStatement());\n};\n\n// Conditional jump.\nEp.jumpIf = function(test, toLoc) {\n  t.assertExpression(test);\n  t.assertLiteral(toLoc);\n\n  this.emit(t.ifStatement(\n    test,\n    t.blockStatement([\n      this.assign(this.contextProperty(\"next\"), toLoc),\n      t.breakStatement()\n    ])\n  ));\n};\n\n// Conditional jump, with the condition negated.\nEp.jumpIfNot = function(test, toLoc) {\n  t.assertExpression(test);\n  t.assertLiteral(toLoc);\n\n  let negatedTest;\n  if (t.isUnaryExpression(test) &&\n      test.operator === \"!\") {\n    // Avoid double negation.\n    negatedTest = test.argument;\n  } else {\n    negatedTest = t.unaryExpression(\"!\", test);\n  }\n\n  this.emit(t.ifStatement(\n    negatedTest,\n    t.blockStatement([\n      this.assign(this.contextProperty(\"next\"), toLoc),\n      t.breakStatement()\n    ])\n  ));\n};\n\n// Returns a unique MemberExpression that can be used to store and\n// retrieve temporary values. Since the object of the member expression is\n// the context object, which is presumed to coexist peacefully with all\n// other local variables, and since we just increment `nextTempId`\n// monotonically, uniqueness is assured.\nEp.makeTempVar = function() {\n  return this.contextProperty(\"t\" + this.nextTempId++);\n};\n\nEp.getContextFunction = function(id) {\n  return t.functionExpression(\n    id || null/*Anonymous*/,\n    [this.contextId],\n    t.blockStatement([this.getDispatchLoop()]),\n    false, // Not a generator anymore!\n    false // Nor an expression.\n  );\n};\n\n// Turns this.listing into a loop of the form\n//\n//   while (1) switch (context.next) {\n//   case 0:\n//   ...\n//   case n:\n//     return context.stop();\n//   }\n//\n// Each marked location in this.listing will correspond to one generated\n// case statement.\nEp.getDispatchLoop = function() {\n  let self = this;\n  let cases = [];\n  let current;\n\n  // If we encounter a break, continue, or return statement in a switch\n  // case, we can skip the rest of the statements until the next case.\n  let alreadyEnded = false;\n\n  self.listing.forEach(function(stmt, i) {\n    if (self.marked.hasOwnProperty(i)) {\n      cases.push(t.switchCase(\n        t.numericLiteral(i),\n        current = []));\n      alreadyEnded = false;\n    }\n\n    if (!alreadyEnded) {\n      current.push(stmt);\n      if (t.isCompletionStatement(stmt))\n        alreadyEnded = true;\n    }\n  });\n\n  // Now that we know how many statements there will be in this.listing,\n  // we can finally resolve this.finalLoc.value.\n  this.finalLoc.value = this.listing.length;\n\n  cases.push(\n    t.switchCase(this.finalLoc, [\n      // Intentionally fall through to the \"end\" case...\n    ]),\n\n    // So that the runtime can jump to the final location without having\n    // to know its offset, we provide the \"end\" case as a synonym.\n    t.switchCase(t.stringLiteral(\"end\"), [\n      // This will check/clear both context.thrown and context.rval.\n      t.returnStatement(\n        t.callExpression(this.contextProperty(\"stop\"), [])\n      )\n    ])\n  );\n\n  return t.whileStatement(\n    t.numericLiteral(1),\n    t.switchStatement(\n      t.assignmentExpression(\n        \"=\",\n        this.contextProperty(\"prev\"),\n        this.contextProperty(\"next\")\n      ),\n      cases\n    )\n  );\n};\n\nEp.getTryLocsList = function() {\n  if (this.tryEntries.length === 0) {\n    // To avoid adding a needless [] to the majority of runtime.wrap\n    // argument lists, force the caller to handle this case specially.\n    return null;\n  }\n\n  let lastLocValue = 0;\n\n  return t.arrayExpression(\n    this.tryEntries.map(function(tryEntry) {\n      let thisLocValue = tryEntry.firstLoc.value;\n      assert.ok(thisLocValue >= lastLocValue, \"try entries out of order\");\n      lastLocValue = thisLocValue;\n\n      let ce = tryEntry.catchEntry;\n      let fe = tryEntry.finallyEntry;\n\n      let locs = [\n        tryEntry.firstLoc,\n        // The null here makes a hole in the array.\n        ce ? ce.firstLoc : null\n      ];\n\n      if (fe) {\n        locs[2] = fe.firstLoc;\n        locs[3] = fe.afterLoc;\n      }\n\n      return t.arrayExpression(locs);\n    })\n  );\n};\n\n// All side effects must be realized in order.\n\n// If any subexpression harbors a leap, all subexpressions must be\n// neutered of side effects.\n\n// No destructive modification of AST nodes.\n\nEp.explode = function(path, ignoreResult) {\n  let node = path.node;\n  let self = this;\n\n  t.assertNode(node);\n\n  if (t.isDeclaration(node))\n    throw getDeclError(node);\n\n  if (t.isStatement(node))\n    return self.explodeStatement(path);\n\n  if (t.isExpression(node))\n    return self.explodeExpression(path, ignoreResult);\n\n  switch (node.type) {\n  case \"Program\":\n    return path.get(\"body\").map(\n      self.explodeStatement,\n      self\n    );\n\n  case \"VariableDeclarator\":\n    throw getDeclError(node);\n\n  // These node types should be handled by their parent nodes\n  // (ObjectExpression, SwitchStatement, and TryStatement, respectively).\n  case \"Property\":\n  case \"SwitchCase\":\n  case \"CatchClause\":\n    throw new Error(\n      node.type + \" nodes should be handled by their parents\");\n\n  default:\n    throw new Error(\n      \"unknown Node of type \" +\n        JSON.stringify(node.type));\n  }\n};\n\nfunction getDeclError(node) {\n  return new Error(\n    \"all declarations should have been transformed into \" +\n    \"assignments before the Exploder began its work: \" +\n    JSON.stringify(node));\n}\n\nEp.explodeStatement = function(path, labelId) {\n  let stmt = path.node;\n  let self = this;\n  let before, after, head;\n\n  t.assertStatement(stmt);\n\n  if (labelId) {\n    t.assertIdentifier(labelId);\n  } else {\n    labelId = null;\n  }\n\n  // Explode BlockStatement nodes even if they do not contain a yield,\n  // because we don't want or need the curly braces.\n  if (t.isBlockStatement(stmt)) {\n    path.get(\"body\").forEach(function (path) {\n      self.explodeStatement(path);\n    });\n    return;\n  }\n\n  if (!meta.containsLeap(stmt)) {\n    // Technically we should be able to avoid emitting the statement\n    // altogether if !meta.hasSideEffects(stmt), but that leads to\n    // confusing generated code (for instance, `while (true) {}` just\n    // disappears) and is probably a more appropriate job for a dedicated\n    // dead code elimination pass.\n    self.emit(stmt);\n    return;\n  }\n\n  switch (stmt.type) {\n  case \"ExpressionStatement\":\n    self.explodeExpression(path.get(\"expression\"), true);\n    break;\n\n  case \"LabeledStatement\":\n    after = loc();\n\n    // Did you know you can break from any labeled block statement or\n    // control structure? Well, you can! Note: when a labeled loop is\n    // encountered, the leap.LabeledEntry created here will immediately\n    // enclose a leap.LoopEntry on the leap manager's stack, and both\n    // entries will have the same label. Though this works just fine, it\n    // may seem a bit redundant. In theory, we could check here to\n    // determine if stmt knows how to handle its own label; for example,\n    // stmt happens to be a WhileStatement and so we know it's going to\n    // establish its own LoopEntry when we explode it (below). Then this\n    // LabeledEntry would be unnecessary. Alternatively, we might be\n    // tempted not to pass stmt.label down into self.explodeStatement,\n    // because we've handled the label here, but that's a mistake because\n    // labeled loops may contain labeled continue statements, which is not\n    // something we can handle in this generic case. All in all, I think a\n    // little redundancy greatly simplifies the logic of this case, since\n    // it's clear that we handle all possible LabeledStatements correctly\n    // here, regardless of whether they interact with the leap manager\n    // themselves. Also remember that labels and break/continue-to-label\n    // statements are rare, and all of this logic happens at transform\n    // time, so it has no additional runtime cost.\n    self.leapManager.withEntry(\n      new leap.LabeledEntry(after, stmt.label),\n      function() {\n        self.explodeStatement(path.get(\"body\"), stmt.label);\n      }\n    );\n\n    self.mark(after);\n\n    break;\n\n  case \"WhileStatement\":\n    before = loc();\n    after = loc();\n\n    self.mark(before);\n    self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n    self.leapManager.withEntry(\n      new leap.LoopEntry(after, before, labelId),\n      function() { self.explodeStatement(path.get(\"body\")); }\n    );\n    self.jump(before);\n    self.mark(after);\n\n    break;\n\n  case \"DoWhileStatement\":\n    let first = loc();\n    let test = loc();\n    after = loc();\n\n    self.mark(first);\n    self.leapManager.withEntry(\n      new leap.LoopEntry(after, test, labelId),\n      function() { self.explode(path.get(\"body\")); }\n    );\n    self.mark(test);\n    self.jumpIf(self.explodeExpression(path.get(\"test\")), first);\n    self.mark(after);\n\n    break;\n\n  case \"ForStatement\":\n    head = loc();\n    let update = loc();\n    after = loc();\n\n    if (stmt.init) {\n      // We pass true here to indicate that if stmt.init is an expression\n      // then we do not care about its result.\n      self.explode(path.get(\"init\"), true);\n    }\n\n    self.mark(head);\n\n    if (stmt.test) {\n      self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n    } else {\n      // No test means continue unconditionally.\n    }\n\n    self.leapManager.withEntry(\n      new leap.LoopEntry(after, update, labelId),\n      function() { self.explodeStatement(path.get(\"body\")); }\n    );\n\n    self.mark(update);\n\n    if (stmt.update) {\n      // We pass true here to indicate that if stmt.update is an\n      // expression then we do not care about its result.\n      self.explode(path.get(\"update\"), true);\n    }\n\n    self.jump(head);\n\n    self.mark(after);\n\n    break;\n\n  case \"TypeCastExpression\":\n    return self.explodeExpression(path.get(\"expression\"));\n\n  case \"ForInStatement\":\n    head = loc();\n    after = loc();\n\n    let keyIterNextFn = self.makeTempVar();\n    self.emitAssign(\n      keyIterNextFn,\n      t.callExpression(\n        util.runtimeProperty(\"keys\"),\n        [self.explodeExpression(path.get(\"right\"))]\n      )\n    );\n\n    self.mark(head);\n\n    let keyInfoTmpVar = self.makeTempVar();\n    self.jumpIf(\n      t.memberExpression(\n        t.assignmentExpression(\n          \"=\",\n          keyInfoTmpVar,\n          t.callExpression(keyIterNextFn, [])\n        ),\n        t.identifier(\"done\"),\n        false\n      ),\n      after\n    );\n\n    self.emitAssign(\n      stmt.left,\n      t.memberExpression(\n        keyInfoTmpVar,\n        t.identifier(\"value\"),\n        false\n      )\n    );\n\n    self.leapManager.withEntry(\n      new leap.LoopEntry(after, head, labelId),\n      function() { self.explodeStatement(path.get(\"body\")); }\n    );\n\n    self.jump(head);\n\n    self.mark(after);\n\n    break;\n\n  case \"BreakStatement\":\n    self.emitAbruptCompletion({\n      type: \"break\",\n      target: self.leapManager.getBreakLoc(stmt.label)\n    });\n\n    break;\n\n  case \"ContinueStatement\":\n    self.emitAbruptCompletion({\n      type: \"continue\",\n      target: self.leapManager.getContinueLoc(stmt.label)\n    });\n\n    break;\n\n  case \"SwitchStatement\":\n    // Always save the discriminant into a temporary variable in case the\n    // test expressions overwrite values like context.sent.\n    let disc = self.emitAssign(\n      self.makeTempVar(),\n      self.explodeExpression(path.get(\"discriminant\"))\n    );\n\n    after = loc();\n    let defaultLoc = loc();\n    let condition = defaultLoc;\n    let caseLocs = [];\n\n    // If there are no cases, .cases might be undefined.\n    let cases = stmt.cases || [];\n\n    for (let i = cases.length - 1; i >= 0; --i) {\n      let c = cases[i];\n      t.assertSwitchCase(c);\n\n      if (c.test) {\n        condition = t.conditionalExpression(\n          t.binaryExpression(\"===\", disc, c.test),\n          caseLocs[i] = loc(),\n          condition\n        );\n      } else {\n        caseLocs[i] = defaultLoc;\n      }\n    }\n\n    let discriminant = path.get(\"discriminant\");\n    discriminant.replaceWith(condition);\n    self.jump(self.explodeExpression(discriminant));\n\n    self.leapManager.withEntry(\n      new leap.SwitchEntry(after),\n      function() {\n        path.get(\"cases\").forEach(function(casePath) {\n          let i = casePath.key;\n          self.mark(caseLocs[i]);\n\n          casePath.get(\"consequent\").forEach(function (path) {\n            self.explodeStatement(path);\n          });\n        });\n      }\n    );\n\n    self.mark(after);\n    if (defaultLoc.value === -1) {\n      self.mark(defaultLoc);\n      assert.strictEqual(after.value, defaultLoc.value);\n    }\n\n    break;\n\n  case \"IfStatement\":\n    let elseLoc = stmt.alternate && loc();\n    after = loc();\n\n    self.jumpIfNot(\n      self.explodeExpression(path.get(\"test\")),\n      elseLoc || after\n    );\n\n    self.explodeStatement(path.get(\"consequent\"));\n\n    if (elseLoc) {\n      self.jump(after);\n      self.mark(elseLoc);\n      self.explodeStatement(path.get(\"alternate\"));\n    }\n\n    self.mark(after);\n\n    break;\n\n  case \"ReturnStatement\":\n    self.emitAbruptCompletion({\n      type: \"return\",\n      value: self.explodeExpression(path.get(\"argument\"))\n    });\n\n    break;\n\n  case \"WithStatement\":\n    throw new Error(\"WithStatement not supported in generator functions.\");\n\n  case \"TryStatement\":\n    after = loc();\n\n    let handler = stmt.handler;\n\n    let catchLoc = handler && loc();\n    let catchEntry = catchLoc && new leap.CatchEntry(\n      catchLoc,\n      handler.param\n    );\n\n    let finallyLoc = stmt.finalizer && loc();\n    let finallyEntry = finallyLoc &&\n      new leap.FinallyEntry(finallyLoc, after);\n\n    let tryEntry = new leap.TryEntry(\n      self.getUnmarkedCurrentLoc(),\n      catchEntry,\n      finallyEntry\n    );\n\n    self.tryEntries.push(tryEntry);\n    self.updateContextPrevLoc(tryEntry.firstLoc);\n\n    self.leapManager.withEntry(tryEntry, function() {\n      self.explodeStatement(path.get(\"block\"));\n\n      if (catchLoc) {\n        if (finallyLoc) {\n          // If we have both a catch block and a finally block, then\n          // because we emit the catch block first, we need to jump over\n          // it to the finally block.\n          self.jump(finallyLoc);\n\n        } else {\n          // If there is no finally block, then we need to jump over the\n          // catch block to the fall-through location.\n          self.jump(after);\n        }\n\n        self.updateContextPrevLoc(self.mark(catchLoc));\n\n        let bodyPath = path.get(\"handler.body\");\n        let safeParam = self.makeTempVar();\n        self.clearPendingException(tryEntry.firstLoc, safeParam);\n\n        bodyPath.traverse(catchParamVisitor, {\n          safeParam: safeParam,\n          catchParamName: handler.param.name\n        });\n\n        self.leapManager.withEntry(catchEntry, function() {\n          self.explodeStatement(bodyPath);\n        });\n      }\n\n      if (finallyLoc) {\n        self.updateContextPrevLoc(self.mark(finallyLoc));\n\n        self.leapManager.withEntry(finallyEntry, function() {\n          self.explodeStatement(path.get(\"finalizer\"));\n        });\n\n        self.emit(t.returnStatement(t.callExpression(\n          self.contextProperty(\"finish\"),\n          [finallyEntry.firstLoc]\n        )));\n      }\n    });\n\n    self.mark(after);\n\n    break;\n\n  case \"ThrowStatement\":\n    self.emit(t.throwStatement(\n      self.explodeExpression(path.get(\"argument\"))\n    ));\n\n    break;\n\n  default:\n    throw new Error(\n      \"unknown Statement of type \" +\n        JSON.stringify(stmt.type));\n  }\n};\n\nlet catchParamVisitor = {\n  Identifier: function(path, state) {\n    if (path.node.name === state.catchParamName && util.isReference(path)) {\n      path.replaceWith(state.safeParam);\n    }\n  },\n\n  Scope: function(path, state) {\n    if (path.scope.hasOwnBinding(state.catchParamName)) {\n      // Don't descend into nested scopes that shadow the catch\n      // parameter with their own declarations.\n      path.skip();\n    }\n  }\n};\n\nEp.emitAbruptCompletion = function(record) {\n  if (!isValidCompletion(record)) {\n    assert.ok(\n      false,\n      \"invalid completion record: \" +\n        JSON.stringify(record)\n    );\n  }\n\n  assert.notStrictEqual(\n    record.type, \"normal\",\n    \"normal completions are not abrupt\"\n  );\n\n  let abruptArgs = [t.stringLiteral(record.type)];\n\n  if (record.type === \"break\" ||\n      record.type === \"continue\") {\n    t.assertLiteral(record.target);\n    abruptArgs[1] = record.target;\n  } else if (record.type === \"return\" ||\n             record.type === \"throw\") {\n    if (record.value) {\n      t.assertExpression(record.value);\n      abruptArgs[1] = record.value;\n    }\n  }\n\n  this.emit(\n    t.returnStatement(\n      t.callExpression(\n        this.contextProperty(\"abrupt\"),\n        abruptArgs\n      )\n    )\n  );\n};\n\nfunction isValidCompletion(record) {\n  let type = record.type;\n\n  if (type === \"normal\") {\n    return !hasOwn.call(record, \"target\");\n  }\n\n  if (type === \"break\" ||\n      type === \"continue\") {\n    return !hasOwn.call(record, \"value\")\n        && t.isLiteral(record.target);\n  }\n\n  if (type === \"return\" ||\n      type === \"throw\") {\n    return hasOwn.call(record, \"value\")\n        && !hasOwn.call(record, \"target\");\n  }\n\n  return false;\n}\n\n\n// Not all offsets into emitter.listing are potential jump targets. For\n// example, execution typically falls into the beginning of a try block\n// without jumping directly there. This method returns the current offset\n// without marking it, so that a switch case will not necessarily be\n// generated for this offset (I say \"not necessarily\" because the same\n// location might end up being marked in the process of emitting other\n// statements). There's no logical harm in marking such locations as jump\n// targets, but minimizing the number of switch cases keeps the generated\n// code shorter.\nEp.getUnmarkedCurrentLoc = function() {\n  return t.numericLiteral(this.listing.length);\n};\n\n// The context.prev property takes the value of context.next whenever we\n// evaluate the switch statement discriminant, which is generally good\n// enough for tracking the last location we jumped to, but sometimes\n// context.prev needs to be more precise, such as when we fall\n// successfully out of a try block and into a finally block without\n// jumping. This method exists to update context.prev to the freshest\n// available location. If we were implementing a full interpreter, we\n// would know the location of the current instruction with complete\n// precision at all times, but we don't have that luxury here, as it would\n// be costly and verbose to set context.prev before every statement.\nEp.updateContextPrevLoc = function(loc) {\n  if (loc) {\n    t.assertLiteral(loc);\n\n    if (loc.value === -1) {\n      // If an uninitialized location literal was passed in, set its value\n      // to the current this.listing.length.\n      loc.value = this.listing.length;\n    } else {\n      // Otherwise assert that the location matches the current offset.\n      assert.strictEqual(loc.value, this.listing.length);\n    }\n\n  } else {\n    loc = this.getUnmarkedCurrentLoc();\n  }\n\n  // Make sure context.prev is up to date in case we fell into this try\n  // statement without jumping to it. TODO Consider avoiding this\n  // assignment when we know control must have jumped here.\n  this.emitAssign(this.contextProperty(\"prev\"), loc);\n};\n\nEp.explodeExpression = function(path, ignoreResult) {\n  let expr = path.node;\n  if (expr) {\n    t.assertExpression(expr);\n  } else {\n    return expr;\n  }\n\n  let self = this;\n  let result; // Used optionally by several cases below.\n  let after;\n\n  function finish(expr) {\n    t.assertExpression(expr);\n    if (ignoreResult) {\n      self.emit(expr);\n    } else {\n      return expr;\n    }\n  }\n\n  // If the expression does not contain a leap, then we either emit the\n  // expression as a standalone statement or return it whole.\n  if (!meta.containsLeap(expr)) {\n    return finish(expr);\n  }\n\n  // If any child contains a leap (such as a yield or labeled continue or\n  // break statement), then any sibling subexpressions will almost\n  // certainly have to be exploded in order to maintain the order of their\n  // side effects relative to the leaping child(ren).\n  let hasLeapingChildren = meta.containsLeap.onlyChildren(expr);\n\n  // In order to save the rest of explodeExpression from a combinatorial\n  // trainwreck of special cases, explodeViaTempVar is responsible for\n  // deciding when a subexpression needs to be \"exploded,\" which is my\n  // very technical term for emitting the subexpression as an assignment\n  // to a temporary variable and the substituting the temporary variable\n  // for the original subexpression. Think of exploded view diagrams, not\n  // Michael Bay movies. The point of exploding subexpressions is to\n  // control the precise order in which the generated code realizes the\n  // side effects of those subexpressions.\n  function explodeViaTempVar(tempVar, childPath, ignoreChildResult) {\n    assert.ok(\n      !ignoreChildResult || !tempVar,\n      \"Ignoring the result of a child expression but forcing it to \" +\n        \"be assigned to a temporary variable?\"\n    );\n\n    let result = self.explodeExpression(childPath, ignoreChildResult);\n\n    if (ignoreChildResult) {\n      // Side effects already emitted above.\n\n    } else if (tempVar || (hasLeapingChildren &&\n                           !t.isLiteral(result))) {\n      // If tempVar was provided, then the result will always be assigned\n      // to it, even if the result does not otherwise need to be assigned\n      // to a temporary variable.  When no tempVar is provided, we have\n      // the flexibility to decide whether a temporary variable is really\n      // necessary.  Unfortunately, in general, a temporary variable is\n      // required whenever any child contains a yield expression, since it\n      // is difficult to prove (at all, let alone efficiently) whether\n      // this result would evaluate to the same value before and after the\n      // yield (see #206).  One narrow case where we can prove it doesn't\n      // matter (and thus we do not need a temporary variable) is when the\n      // result in question is a Literal value.\n      result = self.emitAssign(\n        tempVar || self.makeTempVar(),\n        result\n      );\n    }\n    return result;\n  }\n\n  // If ignoreResult is true, then we must take full responsibility for\n  // emitting the expression with all its side effects, and we should not\n  // return a result.\n\n  switch (expr.type) {\n  case \"MemberExpression\":\n    return finish(t.memberExpression(\n      self.explodeExpression(path.get(\"object\")),\n      expr.computed\n        ? explodeViaTempVar(null, path.get(\"property\"))\n        : expr.property,\n      expr.computed\n    ));\n\n  case \"CallExpression\":\n    let calleePath = path.get(\"callee\");\n    let argsPath = path.get(\"arguments\");\n\n    let newCallee;\n    let newArgs = [];\n\n    let hasLeapingArgs = false;\n    argsPath.forEach(function(argPath) {\n      hasLeapingArgs = hasLeapingArgs ||\n        meta.containsLeap(argPath.node);\n    });\n\n    if (t.isMemberExpression(calleePath.node)) {\n      if (hasLeapingArgs) {\n        // If the arguments of the CallExpression contained any yield\n        // expressions, then we need to be sure to evaluate the callee\n        // before evaluating the arguments, but if the callee was a member\n        // expression, then we must be careful that the object of the\n        // member expression still gets bound to `this` for the call.\n\n        let newObject = explodeViaTempVar(\n          // Assign the exploded callee.object expression to a temporary\n          // variable so that we can use it twice without reevaluating it.\n          self.makeTempVar(),\n          calleePath.get(\"object\")\n        );\n\n        let newProperty = calleePath.node.computed\n          ? explodeViaTempVar(null, calleePath.get(\"property\"))\n          : calleePath.node.property;\n\n        newArgs.unshift(newObject);\n\n        newCallee = t.memberExpression(\n          t.memberExpression(\n            newObject,\n            newProperty,\n            calleePath.node.computed\n          ),\n          t.identifier(\"call\"),\n          false\n        );\n\n      } else {\n        newCallee = self.explodeExpression(calleePath);\n      }\n\n    } else {\n      newCallee = self.explodeExpression(calleePath);\n\n      if (t.isMemberExpression(newCallee)) {\n        // If the callee was not previously a MemberExpression, then the\n        // CallExpression was \"unqualified,\" meaning its `this` object\n        // should be the global object. If the exploded expression has\n        // become a MemberExpression (e.g. a context property, probably a\n        // temporary variable), then we need to force it to be unqualified\n        // by using the (0, object.property)(...) trick; otherwise, it\n        // will receive the object of the MemberExpression as its `this`\n        // object.\n        newCallee = t.sequenceExpression([\n          t.numericLiteral(0),\n          newCallee\n        ]);\n      }\n    }\n\n    argsPath.forEach(function(argPath) {\n      newArgs.push(explodeViaTempVar(null, argPath));\n    });\n\n    return finish(t.callExpression(\n      newCallee,\n      newArgs\n    ));\n\n  case \"NewExpression\":\n    return finish(t.newExpression(\n      explodeViaTempVar(null, path.get(\"callee\")),\n      path.get(\"arguments\").map(function(argPath) {\n        return explodeViaTempVar(null, argPath);\n      })\n    ));\n\n  case \"ObjectExpression\":\n    return finish(t.objectExpression(\n      path.get(\"properties\").map(function(propPath) {\n        if (propPath.isObjectProperty()) {\n          return t.objectProperty(\n            propPath.node.key,\n            explodeViaTempVar(null, propPath.get(\"value\")),\n            propPath.node.computed\n          );\n        } else {\n          return propPath.node;\n        }\n      })\n    ));\n\n  case \"ArrayExpression\":\n    return finish(t.arrayExpression(\n      path.get(\"elements\").map(function(elemPath) {\n        return explodeViaTempVar(null, elemPath);\n      })\n    ));\n\n  case \"SequenceExpression\":\n    let lastIndex = expr.expressions.length - 1;\n\n    path.get(\"expressions\").forEach(function(exprPath) {\n      if (exprPath.key === lastIndex) {\n        result = self.explodeExpression(exprPath, ignoreResult);\n      } else {\n        self.explodeExpression(exprPath, true);\n      }\n    });\n\n    return result;\n\n  case \"LogicalExpression\":\n    after = loc();\n\n    if (!ignoreResult) {\n      result = self.makeTempVar();\n    }\n\n    let left = explodeViaTempVar(result, path.get(\"left\"));\n\n    if (expr.operator === \"&&\") {\n      self.jumpIfNot(left, after);\n    } else {\n      assert.strictEqual(expr.operator, \"||\");\n      self.jumpIf(left, after);\n    }\n\n    explodeViaTempVar(result, path.get(\"right\"), ignoreResult);\n\n    self.mark(after);\n\n    return result;\n\n  case \"ConditionalExpression\":\n    let elseLoc = loc();\n    after = loc();\n    let test = self.explodeExpression(path.get(\"test\"));\n\n    self.jumpIfNot(test, elseLoc);\n\n    if (!ignoreResult) {\n      result = self.makeTempVar();\n    }\n\n    explodeViaTempVar(result, path.get(\"consequent\"), ignoreResult);\n    self.jump(after);\n\n    self.mark(elseLoc);\n    explodeViaTempVar(result, path.get(\"alternate\"), ignoreResult);\n\n    self.mark(after);\n\n    return result;\n\n  case \"UnaryExpression\":\n    return finish(t.unaryExpression(\n      expr.operator,\n      // Can't (and don't need to) break up the syntax of the argument.\n      // Think about delete a[b].\n      self.explodeExpression(path.get(\"argument\")),\n      !!expr.prefix\n    ));\n\n  case \"BinaryExpression\":\n    return finish(t.binaryExpression(\n      expr.operator,\n      explodeViaTempVar(null, path.get(\"left\")),\n      explodeViaTempVar(null, path.get(\"right\"))\n    ));\n\n  case \"AssignmentExpression\":\n    return finish(t.assignmentExpression(\n      expr.operator,\n      self.explodeExpression(path.get(\"left\")),\n      self.explodeExpression(path.get(\"right\"))\n    ));\n\n  case \"UpdateExpression\":\n    return finish(t.updateExpression(\n      expr.operator,\n      self.explodeExpression(path.get(\"argument\")),\n      expr.prefix\n    ));\n\n  case \"YieldExpression\":\n    after = loc();\n    let arg = expr.argument && self.explodeExpression(path.get(\"argument\"));\n\n    if (arg && expr.delegate) {\n      let result = self.makeTempVar();\n\n      self.emit(t.returnStatement(t.callExpression(\n        self.contextProperty(\"delegateYield\"), [\n          arg,\n          t.stringLiteral(result.property.name),\n          after\n        ]\n      )));\n\n      self.mark(after);\n\n      return result;\n    }\n\n    self.emitAssign(self.contextProperty(\"next\"), after);\n    self.emit(t.returnStatement(arg || null));\n    self.mark(after);\n\n    return self.contextProperty(\"sent\");\n\n  default:\n    throw new Error(\n      \"unknown Expression of type \" +\n        JSON.stringify(expr.type));\n  }\n};\n"]}