{"version":3,"sources":["meta.js"],"names":[],"mappings":";;AAUA;;;;AAEA;;IAAY;;;;;;AADZ,IAAI,IAAI,QAAQ,SAAR,EAAmB,YAAnB,EAAJ;;;;;;;;;;AAEJ,IAAI,SAAS,OAAO,SAAP,CAAiB,cAAjB;;AAEb,SAAS,aAAT,CAAuB,YAAvB,EAAqC,UAArC,EAAiD;AAC/C,WAAS,YAAT,CAAsB,IAAtB,EAA4B;AAC1B,MAAE,UAAF,CAAa,IAAb;;;AAD0B,QAItB,SAAS,KAAT,CAJsB;;AAM1B,aAAS,KAAT,CAAe,KAAf,EAAsB;AACpB,UAAI,MAAJ,EAAY;;OAAZ,MAEO,IAAI,MAAM,OAAN,CAAc,KAAd,CAAJ,EAA0B;AAC/B,gBAAM,IAAN,CAAW,KAAX,EAD+B;SAA1B,MAEA,IAAI,EAAE,MAAF,CAAS,KAAT,CAAJ,EAAqB;AAC1B,2BAAO,WAAP,CAAmB,MAAnB,EAA2B,KAA3B,EAD0B;AAE1B,mBAAS,UAAU,KAAV,CAAT,CAF0B;SAArB;AAIP,aAAO,MAAP,CAToB;KAAtB;;AAYA,QAAI,OAAO,EAAE,YAAF,CAAe,KAAK,IAAL,CAAtB,CAlBsB;AAmB1B,QAAI,IAAJ,EAAU;AACR,WAAK,IAAI,IAAI,CAAJ,EAAO,IAAI,KAAK,MAAL,EAAa,GAAjC,EAAsC;AACpC,YAAI,MAAM,KAAK,CAAL,CAAN,CADgC;AAEpC,YAAI,QAAQ,KAAK,GAAL,CAAR,CAFgC;AAGpC,cAAM,KAAN,EAHoC;OAAtC;KADF;;AAQA,WAAO,MAAP,CA3B0B;GAA5B;;AA8BA,WAAS,SAAT,CAAmB,IAAnB,EAAyB;AACvB,MAAE,UAAF,CAAa,IAAb,EADuB;;AAGvB,QAAI,OAAO,EAAE,IAAF,CAAP,CAHmB;AAIvB,QAAI,OAAO,IAAP,CAAY,IAAZ,EAAkB,YAAlB,CAAJ,EACE,OAAO,KAAK,YAAL,CAAP,CADF;;;;AAJuB,QASnB,OAAO,IAAP,CAAY,WAAZ,EAAyB,KAAK,IAAL,CAA7B,EACE,OAAO,KAAK,YAAL,IAAqB,KAArB,CADT;;AAGA,QAAI,OAAO,IAAP,CAAY,UAAZ,EAAwB,KAAK,IAAL,CAA5B,EACE,OAAO,KAAK,YAAL,IAAqB,IAArB,CADT;;AAGA,WAAO,KAAK,YAAL,IAAqB,aAAa,IAAb,CAArB,CAfgB;GAAzB;;AAkBA,YAAU,YAAV,GAAyB,YAAzB,CAjD+C;;AAmD/C,SAAO,SAAP,CAnD+C;CAAjD;;AAsDA,IAAI,cAAc;AAChB,sBAAoB,IAApB;CADE;;;;AAMJ,IAAI,kBAAkB;AACpB,kBAAgB,IAAhB;AACA,kBAAgB,IAAhB;AACA,mBAAiB,IAAjB;AACA,oBAAkB,IAAlB;AACA,wBAAsB,IAAtB;AACA,oBAAkB,IAAlB;AACA,iBAAe,IAAf;AAPoB,CAAlB;;;AAWJ,IAAI,YAAY;AACd,mBAAiB,IAAjB;AACA,kBAAgB,IAAhB;AACA,qBAAmB,IAAnB;AACA,mBAAiB,IAAjB;AACA,kBAAgB,IAAhB;CALE;;;AASJ,KAAK,IAAI,IAAJ,IAAY,SAAjB,EAA4B;AAC1B,MAAI,OAAO,IAAP,CAAY,SAAZ,EAAuB,IAAvB,CAAJ,EAAkC;AAChC,oBAAgB,IAAhB,IAAwB,UAAU,IAAV,CAAxB,CADgC;GAAlC;CADF;;AAMA,QAAQ,cAAR,GAAyB,cAAc,gBAAd,EAAgC,eAAhC,CAAzB;AACA,QAAQ,YAAR,GAAuB,cAAc,cAAd,EAA8B,SAA9B,CAAvB","file":"meta-compiled.js","sourcesContent":["/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\nimport assert from \"assert\";\nlet m = require(\"private\").makeAccessor();\nimport * as t from \"babel-types\";\nlet hasOwn = Object.prototype.hasOwnProperty;\n\nfunction makePredicate(propertyName, knownTypes) {\n  function onlyChildren(node) {\n    t.assertNode(node);\n\n    // Assume no side effects until we find out otherwise.\n    let result = false;\n\n    function check(child) {\n      if (result) {\n        // Do nothing.\n      } else if (Array.isArray(child)) {\n        child.some(check);\n      } else if (t.isNode(child)) {\n        assert.strictEqual(result, false);\n        result = predicate(child);\n      }\n      return result;\n    }\n\n    let keys = t.VISITOR_KEYS[node.type];\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        let key = keys[i];\n        let child = node[key];\n        check(child);\n      }\n    }\n\n    return result;\n  }\n\n  function predicate(node) {\n    t.assertNode(node);\n\n    let meta = m(node);\n    if (hasOwn.call(meta, propertyName))\n      return meta[propertyName];\n\n    // Certain types are \"opaque,\" which means they have no side\n    // effects or leaps and we don't care about their subexpressions.\n    if (hasOwn.call(opaqueTypes, node.type))\n      return meta[propertyName] = false;\n\n    if (hasOwn.call(knownTypes, node.type))\n      return meta[propertyName] = true;\n\n    return meta[propertyName] = onlyChildren(node);\n  }\n\n  predicate.onlyChildren = onlyChildren;\n\n  return predicate;\n}\n\nlet opaqueTypes = {\n  FunctionExpression: true\n};\n\n// These types potentially have side effects regardless of what side\n// effects their subexpressions have.\nlet sideEffectTypes = {\n  CallExpression: true, // Anything could happen!\n  ForInStatement: true, // Modifies the key variable.\n  UnaryExpression: true, // Think delete.\n  BinaryExpression: true, // Might invoke .toString() or .valueOf().\n  AssignmentExpression: true, // Side-effecting by definition.\n  UpdateExpression: true, // Updates are essentially assignments.\n  NewExpression: true // Similar to CallExpression.\n};\n\n// These types are the direct cause of all leaps in control flow.\nlet leapTypes = {\n  YieldExpression: true,\n  BreakStatement: true,\n  ContinueStatement: true,\n  ReturnStatement: true,\n  ThrowStatement: true\n};\n\n// All leap types are also side effect types.\nfor (let type in leapTypes) {\n  if (hasOwn.call(leapTypes, type)) {\n    sideEffectTypes[type] = leapTypes[type];\n  }\n}\n\nexports.hasSideEffects = makePredicate(\"hasSideEffects\", sideEffectTypes);\nexports.containsLeap = makePredicate(\"containsLeap\", leapTypes);\n"]}