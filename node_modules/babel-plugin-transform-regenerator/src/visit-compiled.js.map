{"version":3,"sources":["visit.js"],"names":[],"mappings":"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","file":"visit-compiled.js","sourcesContent":["/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\nimport assert from \"assert\";\nimport * as t from \"babel-types\";\nimport { hoist } from \"./hoist\";\nimport { Emitter } from \"./emit\";\nimport * as util from \"./util\";\n\nlet getMarkInfo = require(\"private\").makeAccessor();\n\nexports.visitor = {\n  Function: {\n    exit: function(path, state) {\n      let node = path.node;\n\n      if (node.generator) {\n        if (node.async) {\n          // Async generator\n          if (state.opts.asyncGenerators === false) return;\n        } else {\n          // Plain generator\n          if (state.opts.generators === false) return;\n        }\n      } else if (node.async) {\n        // Async function\n        if (state.opts.async === false) return;\n      } else {\n        // Not a generator or async function.\n        return;\n      }\n\n      let contextId = path.scope.generateUidIdentifier(\"context\");\n      let argsId = path.scope.generateUidIdentifier(\"args\");\n\n      path.ensureBlock();\n      let bodyBlockPath = path.get(\"body\");\n\n      if (node.async) {\n        bodyBlockPath.traverse(awaitVisitor);\n      }\n\n      bodyBlockPath.traverse(functionSentVisitor, {\n        context: contextId\n      });\n\n      let outerBody = [];\n      let innerBody = [];\n\n      bodyBlockPath.get(\"body\").forEach(function(childPath) {\n        let node = childPath.node;\n        if (node && node._blockHoist != null) {\n          outerBody.push(node);\n        } else {\n          innerBody.push(node);\n        }\n      });\n\n      if (outerBody.length > 0) {\n        // Only replace the inner body if we actually hoisted any statements\n        // to the outer body.\n        bodyBlockPath.node.body = innerBody;\n      }\n\n      let outerFnExpr = getOuterFnExpr(path);\n      // Note that getOuterFnExpr has the side-effect of ensuring that the\n      // function has a name (so node.id will always be an Identifier), even\n      // if a temporary name has to be synthesized.\n      t.assertIdentifier(node.id);\n      let innerFnId = t.identifier(node.id.name + \"$\");\n\n      // Turn all declarations into vars, and replace the original\n      // declarations with equivalent assignment expressions.\n      let vars = hoist(path);\n\n      let didRenameArguments = renameArguments(path, argsId);\n      if (didRenameArguments) {\n        vars = vars || t.variableDeclaration(\"var\", []);\n        vars.declarations.push(t.variableDeclarator(\n          argsId, t.identifier(\"arguments\")\n        ));\n      }\n\n      let emitter = new Emitter(contextId);\n      emitter.explode(path.get(\"body\"));\n\n      if (vars && vars.declarations.length > 0) {\n        outerBody.push(vars);\n      }\n\n      let wrapArgs = [\n        emitter.getContextFunction(innerFnId),\n        // Async functions that are not generators don't care about the\n        // outer function because they don't need it to be marked and don't\n        // inherit from its .prototype.\n        node.generator ? outerFnExpr : t.nullLiteral(),\n        t.thisExpression()\n      ];\n\n      let tryLocsList = emitter.getTryLocsList();\n      if (tryLocsList) {\n        wrapArgs.push(tryLocsList);\n      }\n\n      let wrapCall = t.callExpression(\n        util.runtimeProperty(node.async ? \"async\" : \"wrap\"),\n        wrapArgs\n      );\n\n      outerBody.push(t.returnStatement(wrapCall));\n      node.body = t.blockStatement(outerBody);\n\n      let wasGeneratorFunction = node.generator;\n      if (wasGeneratorFunction) {\n        node.generator = false;\n      }\n\n      if (node.async) {\n        node.async = false;\n      }\n\n      if (wasGeneratorFunction && t.isExpression(node)) {\n        path.replaceWith(t.callExpression(util.runtimeProperty(\"mark\"), [node]));\n      }\n\n      // Generators are processed in 'exit' handlers so that regenerator only has to run on\n      // an ES5 AST, but that means traversal will not pick up newly inserted references\n      // to things like 'regeneratorRuntime'. To avoid this, we explicitly requeue.\n      path.requeue();\n    }\n  }\n};\n\n// Given a NodePath for a Function, return an Expression node that can be\n// used to refer reliably to the function object from inside the function.\n// This expression is essentially a replacement for arguments.callee, with\n// the key advantage that it works in strict mode.\nfunction getOuterFnExpr(funPath) {\n  let node = funPath.node;\n  t.assertFunction(node);\n\n  if (!node.id){\n    // Default-exported function declarations, and function expressions may not\n    // have a name to reference, so we explicitly add one.\n    node.id = funPath.scope.parent.generateUidIdentifier(\"callee\");\n  }\n\n  if (node.generator && // Non-generator functions don't need to be marked.\n      t.isFunctionDeclaration(node)) {\n    let pp = funPath.findParent(function (path) {\n      return path.isProgram() || path.isBlockStatement();\n    });\n\n    if (!pp) {\n      return node.id;\n    }\n\n    let markDecl = getRuntimeMarkDecl(pp);\n    let markedArray = markDecl.declarations[0].id;\n    let funDeclIdArray = markDecl.declarations[0].init.callee.object;\n    t.assertArrayExpression(funDeclIdArray);\n\n    let index = funDeclIdArray.elements.length;\n    funDeclIdArray.elements.push(node.id);\n\n    return t.memberExpression(\n      markedArray,\n      t.numericLiteral(index),\n      true\n    );\n  }\n\n  return node.id;\n}\n\nfunction getRuntimeMarkDecl(blockPath) {\n  let block = blockPath.node;\n  assert.ok(Array.isArray(block.body));\n\n  let info = getMarkInfo(block);\n  if (info.decl) {\n    return info.decl;\n  }\n\n  info.decl = t.variableDeclaration(\"var\", [\n    t.variableDeclarator(\n      blockPath.scope.generateUidIdentifier(\"marked\"),\n      t.callExpression(\n        t.memberExpression(\n          t.arrayExpression([]),\n          t.identifier(\"map\"),\n          false\n        ),\n        [util.runtimeProperty(\"mark\")]\n      )\n    )\n  ]);\n\n  blockPath.unshiftContainer(\"body\", info.decl);\n\n  return info.decl;\n}\n\nfunction renameArguments(funcPath, argsId) {\n  let state = {\n    didRenameArguments: false,\n    argsId: argsId\n  };\n\n  funcPath.traverse(argumentsVisitor, state);\n\n  // If the traversal replaced any arguments references, then we need to\n  // alias the outer function's arguments binding (be it the implicit\n  // arguments object or some other parameter or variable) to the variable\n  // named by argsId.\n  return state.didRenameArguments;\n}\n\nlet argumentsVisitor = {\n  \"FunctionExpression|FunctionDeclaration\": function(path) {\n    path.skip();\n  },\n\n  Identifier: function(path, state) {\n    if (path.node.name === \"arguments\" && util.isReference(path)) {\n      path.replaceWith(state.argsId);\n      state.didRenameArguments = true;\n    }\n  }\n};\n\nlet functionSentVisitor = {\n  MetaProperty(path) {\n    let { node } = path;\n\n    if (node.meta.name === \"function\" && node.property.name === \"sent\") {\n      path.replaceWith(t.memberExpression(this.context, t.identifier(\"_sent\")));\n    }\n  }\n};\n\nlet awaitVisitor = {\n  Function: function(path) {\n    path.skip(); // Don't descend into nested function scopes.\n  },\n\n  AwaitExpression: function(path) {\n    // Convert await expressions to yield expressions.\n    let argument = path.node.argument;\n\n    // Transforming `await x` to `yield regeneratorRuntime.awrap(x)`\n    // causes the argument to be wrapped in such a way that the runtime\n    // can distinguish between awaited and merely yielded values.\n    path.replaceWith(t.yieldExpression(\n      t.callExpression(\n        util.runtimeProperty(\"awrap\"),\n        [argument]\n      ),\n      false\n    ));\n  }\n};\n"]}