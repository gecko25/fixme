{"version":3,"sources":["meta.js"],"names":[],"mappings":"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","file":"meta-compiled.js","sourcesContent":["/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"babel-runtime/helpers/interop-require-default\")[\"default\"];\n\nvar _interopRequireWildcard = require(\"babel-runtime/helpers/interop-require-wildcard\")[\"default\"];\n\nvar _assert = require(\"assert\");\n\nvar _assert2 = _interopRequireDefault(_assert);\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nvar m = require(\"private\").makeAccessor();\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction makePredicate(propertyName, knownTypes) {\n  function onlyChildren(node) {\n    t.assertNode(node);\n\n    // Assume no side effects until we find out otherwise.\n    var result = false;\n\n    function check(child) {\n      if (result) {\n        // Do nothing.\n      } else if (Array.isArray(child)) {\n          child.some(check);\n        } else if (t.isNode(child)) {\n          _assert2[\"default\"].strictEqual(result, false);\n          result = predicate(child);\n        }\n      return result;\n    }\n\n    var keys = t.VISITOR_KEYS[node.type];\n    if (keys) {\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var child = node[key];\n        check(child);\n      }\n    }\n\n    return result;\n  }\n\n  function predicate(node) {\n    t.assertNode(node);\n\n    var meta = m(node);\n    if (hasOwn.call(meta, propertyName)) return meta[propertyName];\n\n    // Certain types are \"opaque,\" which means they have no side\n    // effects or leaps and we don't care about their subexpressions.\n    if (hasOwn.call(opaqueTypes, node.type)) return meta[propertyName] = false;\n\n    if (hasOwn.call(knownTypes, node.type)) return meta[propertyName] = true;\n\n    return meta[propertyName] = onlyChildren(node);\n  }\n\n  predicate.onlyChildren = onlyChildren;\n\n  return predicate;\n}\n\nvar opaqueTypes = {\n  FunctionExpression: true\n};\n\n// These types potentially have side effects regardless of what side\n// effects their subexpressions have.\nvar sideEffectTypes = {\n  CallExpression: true, // Anything could happen!\n  ForInStatement: true, // Modifies the key variable.\n  UnaryExpression: true, // Think delete.\n  BinaryExpression: true, // Might invoke .toString() or .valueOf().\n  AssignmentExpression: true, // Side-effecting by definition.\n  UpdateExpression: true, // Updates are essentially assignments.\n  NewExpression: true // Similar to CallExpression.\n};\n\n// These types are the direct cause of all leaps in control flow.\nvar leapTypes = {\n  YieldExpression: true,\n  BreakStatement: true,\n  ContinueStatement: true,\n  ReturnStatement: true,\n  ThrowStatement: true\n};\n\n// All leap types are also side effect types.\nfor (var type in leapTypes) {\n  if (hasOwn.call(leapTypes, type)) {\n    sideEffectTypes[type] = leapTypes[type];\n  }\n}\n\nexports.hasSideEffects = makePredicate(\"hasSideEffects\", sideEffectTypes);\nexports.containsLeap = makePredicate(\"containsLeap\", leapTypes);"]}